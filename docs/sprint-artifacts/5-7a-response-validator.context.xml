<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>5</epicId>
    <storyId>7a</storyId>
    <title>Response Validator (Post-Validación de Coherencia)</title>
    <status>drafted</status>
    <generatedAt>2025-11-22</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/5-7a-response-validator.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>sistema FSM híbrido</asA>
    <iWant>validar que las respuestas del LLM sean coherentes con el estado actual de la FSM antes de enviarlas al usuario</iWant>
    <soThat>el usuario nunca vea información de estados futuros del booking flow, garantizando sincronización entre lo que el bot dice y el estado real del sistema</soThat>
    <tasks>
      <task id="1" name="Crear modelos de datos para validación">
        <subtask id="1.1">Crear CoherenceResult dataclass en agent/fsm/models.py</subtask>
        <subtask id="1.2">Agregar campos: is_coherent: bool, violations: list[str], correction_hint: str | None, confidence: float</subtask>
        <subtask id="1.3">Unit tests para CoherenceResult</subtask>
      </task>
      <task id="2" name="Implementar ResponseValidator core">
        <subtask id="2.1">Crear agent/fsm/response_validator.py</subtask>
        <subtask id="2.2">Implementar FORBIDDEN_PATTERNS dict mapeando BookingState a lista de regex patterns</subtask>
        <subtask id="2.3">Implementar método validate(response: str, fsm: BookingFSM) -> CoherenceResult</subtask>
        <subtask id="2.4">Implementar _check_patterns(response: str, patterns: list[str]) -> list[str]</subtask>
        <subtask id="2.5">Implementar _generate_correction_hint(violations: list[str], fsm_state: BookingState) -> str</subtask>
        <subtask id="2.6">Optimizar para menos de 100ms (compilar regex una sola vez, sin I/O)</subtask>
        <subtask id="2.7">Unit tests cubriendo todos los estados FSM y patrones</subtask>
      </task>
      <task id="3" name="Definir patrones prohibidos por estado">
        <subtask id="3.1">SERVICE_SELECTION: Prohibir nombres de estilistas, horarios específicos</subtask>
        <subtask id="3.2">STYLIST_SELECTION: Prohibir horarios HH:MM, días de la semana en contexto de disponibilidad</subtask>
        <subtask id="3.3">SLOT_SELECTION: Prohibir confirmación prematura, solicitud de datos cliente</subtask>
        <subtask id="3.4">CUSTOMER_DATA: Prohibir confirmación de cita sin datos completos</subtask>
        <subtask id="3.5">Documentar patrones con ejemplos de violaciones</subtask>
      </task>
      <task id="4" name="Implementar regeneración de respuestas">
        <subtask id="4.1">Crear función regenerate_with_correction(messages, correction_hint, fsm) -> str</subtask>
        <subtask id="4.2">Agregar correction_hint como SystemMessage adicional al LLM</subtask>
        <subtask id="4.3">Implementar límite de 1 regeneración (evitar loops infinitos)</subtask>
        <subtask id="4.4">Logging de regeneraciones con contexto completo</subtask>
        <subtask id="4.5">Unit tests para regeneración exitosa y fallida</subtask>
      </task>
      <task id="5" name="Integrar en conversational_agent.py">
        <subtask id="5.1">Importar ResponseValidator en agent/nodes/conversational_agent.py</subtask>
        <subtask id="5.2">Llamar validator.validate() después de generar respuesta LLM</subtask>
        <subtask id="5.3">Si incoherente: llamar regenerate_with_correction() una vez</subtask>
        <subtask id="5.4">Si segunda respuesta incoherente: log WARNING y enviar respuesta genérica</subtask>
        <subtask id="5.5">Integration tests del flujo completo</subtask>
      </task>
      <task id="6" name="Implementar logging estructurado">
        <subtask id="6.1">Agregar logs en validate() con contexto FSM</subtask>
        <subtask id="6.2">Log truncado de respuesta (max 200 chars) para debugging</subtask>
        <subtask id="6.3">Log de violaciones con detalles</subtask>
        <subtask id="6.4">Log de métricas: tiempo de validación, regeneraciones necesarias</subtask>
        <subtask id="6.5">Tests que verifican estructura de logs</subtask>
      </task>
      <task id="7" name="Testing comprehensivo">
        <subtask id="7.1">Crear tests/unit/test_response_validator.py</subtask>
        <subtask id="7.2">Tests para cada estado FSM con respuestas coherentes e incoherentes</subtask>
        <subtask id="7.3">Tests de rendimiento (menos de 100ms)</subtask>
        <subtask id="7.4">Crear tests/integration/test_response_coherence.py</subtask>
        <subtask id="7.5">Integration tests con conversational_agent real</subtask>
        <subtask id="7.6">Coverage mayor a 85% para código nuevo</subtask>
      </task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="AC1">Given el ResponseValidator recibe una respuesta del LLM y el estado actual de la FSM, When evalúa la respuesta, Then retorna un CoherenceResult indicando si es coherente, lista de violaciones, hint de corrección y nivel de confianza</criterion>
    <criterion id="AC2">Given la FSM está en estado SERVICE_SELECTION, When el LLM genera una respuesta que menciona nombres de estilistas (Ana, María, Carlos, Pilar, Laura) o muestra horarios disponibles, Then el validator detecta la incoherencia y marca is_coherent = False con violación específica</criterion>
    <criterion id="AC3">Given la FSM está en estado STYLIST_SELECTION, When el LLM genera una respuesta que menciona horarios específicos (HH:MM) o días de la semana, Then el validator detecta la incoherencia y marca is_coherent = False con violación específica</criterion>
    <criterion id="AC4">Given la FSM está en estado SLOT_SELECTION, When el LLM genera una respuesta que intenta confirmar la cita o menciona datos del cliente sin haberlos recopilado, Then el validator detecta la incoherencia y marca is_coherent = False</criterion>
    <criterion id="AC5">Given una respuesta detectada como incoherente (is_coherent = False), When se invoca regenerate_with_correction(), Then el sistema regenera una respuesta coherente usando el correction_hint y sin superar 1 intento de regeneración</criterion>
    <criterion id="AC6">Given cualquier validación de respuesta, When se ejecuta, Then el tiempo de validación es menor a 100ms (sin I/O de red para patrones)</criterion>
    <criterion id="AC7">Given cualquier llamada al validator, When se ejecuta, Then los logs muestran: estado FSM, respuesta original (truncada), resultado de coherencia, violaciones si las hay</criterion>
    <criterion id="AC8">Given el ResponseValidator integrado en conversational_agent.py, When se completa el flujo de generación de respuesta, Then la respuesta final enviada al usuario siempre es coherente con el estado FSM</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/sprint-change-proposal-2025-11-22-response-coherence.md</path>
        <title>Sprint Change Proposal - Response Coherence Layer</title>
        <section>Solución Propuesta</section>
        <snippet>Implementar Response Coherence Layer usando enfoque híbrido: Fase 1 post-validación de respuestas del LLM (safety net), Fase 2 FSM Directives ligeras para guiar al LLM (proactivo).</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-5.md</path>
        <title>Epic 5 Technical Specification - FSM Híbrida</title>
        <section>System Architecture Alignment</section>
        <snippet>La arquitectura separa responsabilidades: LLM solo maneja NLU y generación de lenguaje, mientras FSM controla flujo de conversación.</snippet>
      </doc>
      <doc>
        <path>docs/epics/epic-5-rediseño-fsm-hibrida.md</path>
        <title>Epic 5 - Rediseño FSM Híbrida</title>
        <section>Arquitectura FSM Propuesta</section>
        <snippet>7 estados del booking flow: IDLE, SERVICE_SELECTION, STYLIST_SELECTION, SLOT_SELECTION, CUSTOMER_DATA, CONFIRMATION, BOOKED.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture Document</title>
        <section>ADR-006: FSM Híbrida para Control de Flujo</section>
        <snippet>ADR-006 establece FSM híbrida donde FSM valida intents del usuario. Response Coherence Layer (ADR-007) extiende para validar respuestas del LLM.</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/5-4-refactorizacion-tools-fsm-validation.md</path>
        <title>Story 5-4 - Tool Validation</title>
        <section>Dev Agent Record</section>
        <snippet>Story 5-4 estableció el patrón de validación centralizada con TOOL_STATE_PERMISSIONS - seguir mismo patrón para FORBIDDEN_PATTERNS.</snippet>
      </doc>
      <doc>
        <path>CLAUDE.md</path>
        <title>Project Guidelines</title>
        <section>Testing Strategy</section>
        <snippet>Unit tests (tests/unit/), Integration tests (tests/integration/), coverage requirement 85% minimum.</snippet>
      </doc>
    </docs>
    <code>
      <file>
        <path>agent/fsm/models.py</path>
        <kind>models</kind>
        <symbol>BookingState, Intent, IntentType, FSMResult</symbol>
        <lines>1-112</lines>
        <reason>Modelos base de FSM. CoherenceResult debe añadirse aquí siguiendo el mismo patrón (dataclass).</reason>
      </file>
      <file>
        <path>agent/fsm/booking_fsm.py</path>
        <kind>controller</kind>
        <symbol>BookingFSM</symbol>
        <lines>1-389</lines>
        <reason>Controlador FSM con estados y transiciones. ResponseValidator necesita acceder a fsm.state y fsm.collected_data para validación.</reason>
      </file>
      <file>
        <path>agent/fsm/tool_validation.py</path>
        <kind>validation</kind>
        <symbol>TOOL_STATE_PERMISSIONS, validate_tool_call, ToolValidationResult</symbol>
        <lines>1-436</lines>
        <reason>Patrón de validación centralizada a seguir. FORBIDDEN_PATTERNS debe estructurarse similar a TOOL_STATE_PERMISSIONS.</reason>
      </file>
      <file>
        <path>agent/fsm/__init__.py</path>
        <kind>module exports</kind>
        <symbol>__all__</symbol>
        <lines>1-69</lines>
        <reason>Debe exportar ResponseValidator, CoherenceResult después de implementación.</reason>
      </file>
      <file>
        <path>agent/nodes/conversational_agent.py</path>
        <kind>node</kind>
        <symbol>conversational_agent, execute_tool_call</symbol>
        <lines>686-805</lines>
        <reason>Punto de integración. Validación debe añadirse después de línea 686 donde se genera assistant_response.</reason>
      </file>
      <file>
        <path>shared/logging.py</path>
        <kind>utility</kind>
        <symbol>logger</symbol>
        <lines>N/A</lines>
        <reason>Logging estructurado del proyecto. Seguir mismo patrón para log_validation_result().</reason>
      </file>
    </code>
    <dependencies>
      <python>
        <package name="langgraph" version=">=0.6.7">Agent orchestration</package>
        <package name="langchain" version=">=0.3.0">LLM integration</package>
        <package name="langchain-openai" version=">=0.3.0">OpenRouter API client</package>
        <package name="redis" version=">=5.0.0">FSM state persistence</package>
        <package name="pydantic" version=">=2.9.0">Model validation</package>
        <package name="pytest" version=">=8.3.0">Testing framework</package>
        <package name="pytest-asyncio" version=">=0.24.0">Async test support</package>
      </python>
      <note>No se requieren nuevas dependencias para Story 5-7a. Regex patterns usan biblioteca estándar `re`.</note>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint type="performance">Validación debe completarse en menos de 100ms (regex precompilados, sin I/O de red)</constraint>
    <constraint type="pattern">Seguir estructura de tool_validation.py para mapeo estado-a-reglas</constraint>
    <constraint type="integration">Integrar DESPUÉS de generación de respuesta (línea 686), no reemplazar flujo existente</constraint>
    <constraint type="regeneration">Máximo 1 intento de regeneración para evitar loops infinitos</constraint>
    <constraint type="logging">Usar mismo patrón de logging estructurado que log_tool_execution()</constraint>
    <constraint type="testing">Coverage mayor a 85% para código nuevo, tests para cada estado FSM</constraint>
    <constraint type="backwards-compatibility">Código existente debe seguir funcionando sin ResponseValidator si se desactiva</constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>ResponseValidator</name>
      <kind>class</kind>
      <signature>class ResponseValidator</signature>
      <path>agent/fsm/response_validator.py</path>
      <methods>
        <method>validate(response: str, fsm: BookingFSM) -> CoherenceResult</method>
        <method>_check_patterns(response: str, patterns: list[re.Pattern]) -> list[str]</method>
        <method>_generate_correction_hint(violations: list[str], fsm_state: BookingState) -> str</method>
      </methods>
    </interface>
    <interface>
      <name>CoherenceResult</name>
      <kind>dataclass</kind>
      <signature>@dataclass class CoherenceResult</signature>
      <path>agent/fsm/models.py</path>
      <fields>
        <field>is_coherent: bool</field>
        <field>violations: list[str]</field>
        <field>correction_hint: str | None</field>
        <field>confidence: float</field>
      </fields>
    </interface>
    <interface>
      <name>regenerate_with_correction</name>
      <kind>async function</kind>
      <signature>async def regenerate_with_correction(messages: list, correction_hint: str, fsm: BookingFSM) -> str</signature>
      <path>agent/fsm/response_validator.py</path>
    </interface>
    <interface>
      <name>FORBIDDEN_PATTERNS</name>
      <kind>constant dict</kind>
      <signature>FORBIDDEN_PATTERNS: dict[BookingState, list[re.Pattern]]</signature>
      <path>agent/fsm/response_validator.py</path>
    </interface>
  </interfaces>

  <tests>
    <standards>El proyecto usa pytest con pytest-asyncio para tests asíncronos. Configuración asyncio_mode=auto. Los tests unitarios van en tests/unit/ y los de integración en tests/integration/. Coverage mínimo requerido: 85%. Tests deben usar fixtures para setup de FSM y mocking de LLM.</standards>
    <locations>
      <location>tests/unit/test_response_validator.py</location>
      <location>tests/integration/test_response_coherence.py</location>
      <location>tests/unit/test_coherence_result.py</location>
    </locations>
    <ideas>
      <idea acId="AC1">Test CoherenceResult dataclass fields initialization and defaults</idea>
      <idea acId="AC2">Test SERVICE_SELECTION state: detect stylist names (Ana, María, Carlos, Pilar, Laura) in response</idea>
      <idea acId="AC2">Test SERVICE_SELECTION state: detect time slots patterns in response</idea>
      <idea acId="AC3">Test STYLIST_SELECTION state: detect HH:MM time patterns in response</idea>
      <idea acId="AC3">Test STYLIST_SELECTION state: detect weekday names in availability context</idea>
      <idea acId="AC4">Test SLOT_SELECTION state: detect premature confirmation language</idea>
      <idea acId="AC4">Test SLOT_SELECTION state: detect customer data requests before slot selection</idea>
      <idea acId="AC5">Test regenerate_with_correction produces coherent response</idea>
      <idea acId="AC5">Test regeneration limit (max 1 attempt)</idea>
      <idea acId="AC6">Test validation time is under 100ms with performance benchmark</idea>
      <idea acId="AC7">Test log output contains fsm_state, response preview, violations</idea>
      <idea acId="AC8">Integration test: full flow with conversational_agent returning coherent response</idea>
      <idea acId="AC8">Integration test: incoherent response triggers regeneration</idea>
    </ideas>
  </tests>
</story-context>
