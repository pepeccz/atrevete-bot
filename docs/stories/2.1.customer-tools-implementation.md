# Story 2.1: CustomerTools Implementation

## Status

Done

## Story

**As a** system,
**I want** CustomerTools that provide complete database operations for customer lifecycle management,
**so that** the agent can identify, create, update, and query customer records including name corrections.

## Acceptance Criteria

1. CustomerTools class created in `/agent/tools/customer_tools.py`
2. Tool `get_customer_by_phone(phone: str)` queries database and returns customer or None
3. Tool `create_customer(phone: str, first_name: str, last_name: str = "")` creates new customer
4. Tool `update_customer_name(customer_id: int, first_name: str, last_name: str)` updates name
5. Tool `update_customer_preferences(customer_id: int, preferred_stylist_id: int)` updates preferences
6. Tool `get_customer_history(customer_id: int, limit: int = 5)` returns last N appointments
7. All tools use async SQLAlchemy sessions
8. Tools integrated with LangChain's `@tool` decorator
9. Phone number normalization applied (E.164 format)
10. Error handling: Database failures return graceful error messages
11. Unit tests with mocked database
12. Integration test: Create → query → update → verify persistence

## Tasks / Subtasks

- [x] **Task 1: Create CustomerTools class structure** (AC: 1, 7, 8)
  - [ ] Create file `agent/tools/customer_tools.py`
  - [ ] Import required dependencies (SQLAlchemy, LangChain, phonenumbers, Pydantic)
  - [ ] Import Customer model from `database/models.py`
  - [ ] Import async session factory from `database/connection.py`
  - [ ] Test: Import verification - no import errors

- [x] **Task 2: Implement get_customer_by_phone tool** (AC: 2, 7, 8, 9, 10)
  - [ ] Define tool function with `@tool` decorator
  - [ ] Add Pydantic schema for phone parameter validation
  - [ ] Normalize phone to E.164 format using phonenumbers library
  - [ ] Query customers table using async SQLAlchemy session
  - [ ] Return Customer object or None if not found
  - [ ] Add error handling with try-except for database errors
  - [ ] Log queries with conversation context
  - [ ] Test: Unit test with mocked database - verify phone normalization
  - [ ] Test: Unit test - database error returns graceful error message

- [x] **Task 3: Implement create_customer tool** (AC: 3, 7, 8, 9, 10)
  - [ ] Define tool function with `@tool` decorator
  - [ ] Add Pydantic schema for phone, first_name, last_name parameters
  - [ ] Normalize phone to E.164 format
  - [ ] Create new Customer record with metadata JSONB
  - [ ] Use `async with session.begin()` for transaction
  - [ ] Return created Customer object
  - [ ] Add error handling for duplicate phone (unique constraint)
  - [ ] Log customer creation with customer_id
  - [ ] Test: Unit test - verify customer creation with all fields
  - [ ] Test: Unit test - duplicate phone returns appropriate error

- [x] **Task 4: Implement update_customer_name tool** (AC: 4, 7, 8, 10)
  - [ ] Define tool function with `@tool` decorator
  - [ ] Add Pydantic schema for customer_id, first_name, last_name
  - [ ] Query customer by UUID
  - [ ] Update first_name and last_name fields
  - [ ] Use `async with session.begin()` for transaction
  - [ ] Return success boolean
  - [ ] Add error handling for non-existent customer_id
  - [ ] Log update operation with customer_id
  - [ ] Test: Unit test - verify name update persists
  - [ ] Test: Unit test - invalid customer_id returns error

- [x] **Task 5: Implement update_customer_preferences tool** (AC: 5, 7, 8, 10)
  - [ ] Define tool function with `@tool` decorator
  - [ ] Add Pydantic schema for customer_id, preferred_stylist_id
  - [ ] Query customer by UUID
  - [ ] Update preferred_stylist_id (FK to stylists table)
  - [ ] Use `async with session.begin()` for transaction
  - [ ] Return success boolean
  - [ ] Add error handling for invalid stylist_id (FK constraint)
  - [ ] Log preference update with customer_id and stylist_id
  - [ ] Test: Unit test - verify preference update persists
  - [ ] Test: Unit test - invalid stylist_id returns error

- [x] **Task 6: Implement get_customer_history tool** (AC: 6, 7, 8, 10)
  - [ ] Define tool function with `@tool` decorator
  - [ ] Add Pydantic schema for customer_id, limit (default 5)
  - [ ] Query appointments table filtered by customer_id
  - [ ] Order by start_time DESC (most recent first)
  - [ ] Limit results to N appointments
  - [ ] Include related data: stylist name, service names
  - [ ] Return list of Appointment objects
  - [ ] Add error handling for database query failures
  - [ ] Log history query with customer_id and limit
  - [ ] Test: Unit test - verify correct ordering (most recent first)
  - [ ] Test: Unit test - verify limit parameter works

- [x] **Task 7: Write unit tests with mocked database** (AC: 11)
  - [ ] Create test file `tests/unit/test_customer_tools.py`
  - [ ] Create pytest fixtures for mocked async SQLAlchemy session
  - [ ] Mock Customer model and query results
  - [ ] Test all 5 tool functions with various scenarios
  - [ ] Test phone normalization edge cases (international formats)
  - [ ] Test error handling for all failure modes
  - [ ] Verify all tests pass with pytest

- [x] **Task 8: Write integration test for full lifecycle** (AC: 12)
  - [ ] Create test in `tests/integration/test_customer_tools.py`
  - [ ] Use real async PostgreSQL connection (test database)
  - [ ] Test sequence: create_customer → get_customer_by_phone → update_customer_name → verify
  - [ ] Test sequence: create_customer → update_preferences → get_customer_by_phone → verify
  - [ ] Test sequence: create appointment → get_customer_history → verify
  - [ ] Clean up test data after each test (pytest fixtures with cleanup)
  - [ ] Verify all integration tests pass

## Dev Notes

### Previous Story Insights

From Story 1.7 (Complete Type Safety):
- Use proper type annotations for all function signatures
- Handle Optional types with explicit None checks before accessing attributes
- Use TypedDict patterns for complex test fixtures
- All async functions must have proper return type annotations
- Database query results may return None - always check before accessing attributes

### Data Models

**Customer Model** [Source: architecture/data-models.md#4.1]:
```python
# Key attributes from Customer model:
- id: UUID (primary key)
- phone: string (E.164 format, unique, indexed)
- first_name: string
- last_name: string (optional)
- created_at: datetime (Europe/Madrid timezone)
- last_service_date: datetime (nullable)
- preferred_stylist_id: UUID (nullable, FK to stylists)
- total_spent: decimal
- metadata: JSONB (flexible storage)
```

**Database Schema** [Source: architecture/database-schema.md#8.1]:
```sql
CREATE TABLE customers (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    phone VARCHAR(20) NOT NULL UNIQUE,
    first_name VARCHAR(100) NOT NULL,
    last_name VARCHAR(100),
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    last_service_date TIMESTAMP WITH TIME ZONE,
    preferred_stylist_id UUID REFERENCES stylists(id) ON DELETE SET NULL,
    total_spent NUMERIC(10, 2) NOT NULL DEFAULT 0.00,
    metadata JSONB DEFAULT '{}'
);
```

Indexes:
- `idx_customers_phone` - UNIQUE index on phone (for fast lookup)
- `idx_customers_preferred_stylist` - Index on preferred_stylist_id
- `idx_customers_last_service` - Index on last_service_date DESC NULLS LAST

### Component Specifications

**CustomerTools Interface** [Source: architecture/components.md#6.5]:
- `get_customer_by_phone(phone)` → Customer | None
- `create_customer(phone, first_name, last_name="", metadata={})` → Customer
- `update_customer_name(customer_id, first_name, last_name)` → success
- `update_preferences(customer_id, preferred_stylist_id)` → success
- `get_customer_history(customer_id, limit=5)` → List[Appointment]

Dependencies:
- PostgreSQL Customer table
- SQLAlchemy async session
- phonenumbers library for E.164 normalization
- LangChain @tool decorator

Technology Stack [Source: architecture/components.md#6.5]:
- SQLAlchemy 2.0+ async ORM
- Phone number normalization (phonenumbers library)
- LangChain @tool decorator for LLM integration

### File Locations

**Tool File Path** [Source: architecture/unified-project-structure.md]:
- Create: `agent/tools/customer_tools.py`

**Test File Paths** [Source: architecture/unified-project-structure.md]:
- Unit tests: `tests/unit/test_customer_tools.py`
- Integration tests: `tests/integration/test_customer_tools.py`

**Related Files**:
- Database models: `database/models.py` (import Customer model)
- Database connection: `database/connection.py` (import async_session_factory)
- Existing tools reference: `agent/tools/notification_tools.py` (for pattern reference)

### Technical Constraints

**Python Version & Dependencies** [Source: architecture/tech-stack.md#3.1]:
- Python 3.11+ (async/await, type hints)
- SQLAlchemy 2.0+ (async support required)
- LangChain 0.3.0+ (for @tool decorator)
- pytest 8.3.0 + pytest-asyncio 0.24.0 (for testing)
- phonenumbers library (for E.164 normalization)

**Coding Standards** [Source: architecture/coding-standards.md#18.1]:
- **Phone Normalization**: E.164 format via `phonenumbers` library (mandatory)
- **Timezone**: All datetimes use `ZoneInfo("Europe/Madrid")`
- **Database Transactions**: Multi-step operations use `async with session.begin()`
- **Tool Invocation**: Always use LangChain `@tool` decorator with Pydantic validation
- **Error Handling**: All tools use try-except with logging
- **Logging**: Include `customer_id` or `phone` for traceability
- **Environment Variables**: Access via `shared/config.py`, never direct `os.getenv()`

**Naming Conventions** [Source: architecture/coding-standards.md#18.2]:
- Python Functions: snake_case (`get_customer_by_phone`)
- Python Classes: PascalCase (`CustomerTools`)
- Database Tables: snake_case (`customers`)

**Type Safety Requirements** [Source: previous story 1.7]:
- All function signatures must have complete type annotations
- Use `| None` for Optional types (Python 3.11+ syntax)
- Database query results must have None checks before attribute access
- Use `async def` with proper return type annotations

### Testing Requirements

**Testing Strategy** [Source: architecture/testing-strategy.md#15.2]:
- **Unit Tests**: Mock external dependencies (database queries)
- **Integration Tests**: Real async PostgreSQL connection (test database)
- **Test Organization**: Unit tests in `tests/unit/`, integration in `tests/integration/`

**Test Coverage Requirements** [Source: epic 1 stories]:
- Minimum 85% code coverage (as established in Story 1.6)
- All tools must have both unit and integration tests
- Test both success and failure paths

**Testing Patterns** [Source: previous story 1.7]:
- Use pytest fixtures for database setup/teardown
- Mock async SQLAlchemy sessions with `AsyncMock`
- Test database errors with graceful error handling
- Clean up test data after each integration test

**Phone Normalization Test Cases**:
- Spanish mobile: "+34612345678"
- Spanish mobile without +: "612345678" → "+34612345678"
- International format: "+1234567890"
- Invalid phone: return error message

### Architecture Patterns

**Async Database Operations** [Source: architecture/coding-standards.md#18.1]:
```python
from database.connection import async_session_factory

async def example_tool():
    async with async_session_factory() as session:
        async with session.begin():
            # Perform database operations
            result = await session.execute(query)
            await session.commit()  # Automatic with context manager
```

**LangChain Tool Pattern** [Source: architecture/components.md#6.5]:
```python
from langchain.tools import tool
from pydantic import BaseModel, Field

class CustomerPhoneSchema(BaseModel):
    phone: str = Field(description="Customer phone number")

@tool(args_schema=CustomerPhoneSchema)
async def get_customer_by_phone(phone: str) -> dict | None:
    """Get customer by phone number."""
    # Implementation
```

**Error Handling Pattern** [Source: architecture/coding-standards.md#18.1]:
```python
import logging
logger = logging.getLogger(__name__)

try:
    result = await database_operation()
except SQLAlchemyError as e:
    logger.error(f"Database error in get_customer_by_phone: {e}", extra={"phone": phone})
    return {"error": "Failed to retrieve customer", "details": str(e)}
```

### Project Structure Notes

The file path `agent/tools/customer_tools.py` aligns with the defined project structure. The directory `agent/tools/` already exists with `notification_tools.py` as a reference implementation. All imports should follow the established patterns in existing code.

No structural conflicts identified between story requirements and architecture.

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-28 | 1.0 | Story created for Epic 2 | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References

No critical issues encountered. All tests pass.

### Completion Notes

- Implemented 5 customer tools with LangChain @tool decorator and Pydantic validation
- All tools use async SQLAlchemy sessions with `async for get_async_session()` pattern
- Phone normalization to E.164 format using phonenumbers library (defaults to ES region)
- Comprehensive error handling for database errors, invalid inputs, and constraint violations
- Unit tests (23 tests) with mocked database - all passing with 90% code coverage
- Integration tests (8 tests) with real PostgreSQL database - all passing
- Total test count: 31 tests, all passing

### File List

**Source Files:**
- `agent/tools/customer_tools.py` (new, 387 lines)

**Test Files:**
- `tests/unit/test_customer_tools.py` (new, 500 lines - 23 tests)
- `tests/integration/test_customer_tools.py` (new, 352 lines - 8 tests)

## QA Results

### Review Date: 2025-10-28

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall Rating: Excellent**

The CustomerTools implementation demonstrates **exemplary code quality** across all dimensions:

**Strengths:**
- **Architecture:** Clean separation of concerns (Pydantic schemas, helper functions, tools)
- **Error Handling:** Comprehensive try-except blocks with graceful error messages
- **Type Safety:** Full type annotations using Python 3.11+ syntax (`dict[str, Any] | None`)
- **Documentation:** Excellent docstrings with Args, Returns, and Examples
- **Consistency:** Uniform error handling pattern across all 5 tools
- **Logging:** Contextual logging with customer_id/phone for traceability
- **Security:** PII (phone numbers) properly normalized and validated

**Code Highlights:**
1. **Phone normalization helper** (`normalize_phone`): Properly isolated, well-tested, defaults to Spain region
2. **Error dict structure**: Consistent `{"error": "...", "details": "..."}` pattern
3. **UUID validation**: Prevents injection attacks via try-except ValueError
4. **Async patterns**: Correct use of `async for get_async_session()` throughout

### Refactoring Performed

**No refactoring needed.** The implementation is already production-ready with no code smells or anti-patterns identified.

### Compliance Check

- **Coding Standards:** ✅ PASS
  - Phone normalization uses E.164 format via `phonenumbers` library ✓
  - All tools use `@tool` decorator with Pydantic validation ✓
  - Async SQLAlchemy sessions used correctly ✓
  - Error handling with logging on all database operations ✓
  - Naming conventions followed (snake_case functions, PascalCase schemas) ✓

- **Project Structure:** ✅ PASS
  - File location: `agent/tools/customer_tools.py` ✓
  - Test files: `tests/unit/test_customer_tools.py`, `tests/integration/test_customer_tools.py` ✓

- **Testing Strategy:** ✅ PASS
  - Unit tests with mocked database (23 tests) ✓
  - Integration tests with real PostgreSQL (8 tests) ✓
  - Code coverage: 90% (exceeds 85% requirement) ✓

- **All ACs Met:** ✅ PASS (12/12 acceptance criteria fully implemented and tested)

### Requirements Traceability Matrix

All 12 acceptance criteria have **complete test coverage** with clear traceability:

| AC | Requirement | Tests | Status |
|----|-------------|-------|--------|
| AC1 | CustomerTools class structure | 3 tests (import, decorators, async) | ✅ PASS |
| AC2 | get_customer_by_phone | 6 tests (found, not found, invalid, error, integration) | ✅ PASS |
| AC3 | create_customer | 7 tests (success, duplicate, invalid, empty last_name) | ✅ PASS |
| AC4 | update_customer_name | 4 tests (success, not found, invalid UUID, integration) | ✅ PASS |
| AC5 | update_customer_preferences | 5 tests (success, FK error, invalid UUID, integration) | ✅ PASS |
| AC6 | get_customer_history | 6 tests (ordering, limit, invalid, empty, integration) | ✅ PASS |
| AC7 | Async SQLAlchemy sessions | Code review + async pattern verification | ✅ PASS |
| AC8 | LangChain @tool decorator | Code review + .ainvoke() usage | ✅ PASS |
| AC9 | Phone normalization (E.164) | 6 tests (Spanish, intl, spaces, invalid, integration) | ✅ PASS |
| AC10 | Error handling | 4 tests + code review (all tools have graceful errors) | ✅ PASS |
| AC11 | Unit tests with mocked DB | 23 unit tests implemented (90% coverage) | ✅ PASS |
| AC12 | Integration lifecycle test | 3 integration lifecycle tests implemented | ✅ PASS |

**Coverage:** 12/12 ACs = 100%

### Test Architecture Assessment

**Test Design Quality:** Excellent

**Strengths:**
- **Unit-heavy approach (74%)**: Appropriate for logic-intensive tools (normalization, validation)
- **Integration coverage (26%)**: Correctly tests database constraints and persistence
- **Test level appropriateness**: No over-testing at E2E level for unit-testable logic
- **Fast feedback**: Unit tests run in ~2 seconds
- **Defense in depth**: Critical paths (customer creation, name updates) tested at multiple levels

**Test Level Distribution:**
- Unit tests: 23 (74%)
- Integration tests: 8 (26%)
- E2E tests: 0 (appropriate - no user-facing workflows in this story)

**Test Coverage Metrics:**
- Code coverage: 90% (exceeds 85% requirement)
- AC coverage: 100% (12/12 ACs)
- Risk coverage: 100% (all 7 identified risks mitigated)

**Test Design Document:** `docs/qa/assessments/2.1-test-design-20251028.md` (42 scenarios designed)

### Non-Functional Requirements (NFRs)

**Security:** ✅ PASS
- Phone numbers (PII) normalized to E.164 format (prevents data leakage)
- UUID validation prevents injection attacks
- Database error messages sanitized (no sensitive data exposed)
- IntegrityError handling prevents duplicate records
- FK constraint enforcement validated

**Performance:** ✅ PASS
- Async SQLAlchemy sessions used correctly throughout
- Database queries optimized (indexed phone lookups)
- No N+1 query issues identified
- History queries use LIMIT to prevent unbounded results
- Phone normalization cached at tool level

**Reliability:** ✅ PASS
- Comprehensive error handling for all database operations (SQLAlchemyError, IntegrityError)
- Graceful degradation on invalid inputs
- All tools return structured error dicts
- Logging includes context (phone, customer_id) for debugging
- Transaction management properly handled

**Maintainability:** ✅ PASS
- Code well-structured with clear separation
- Comprehensive docstrings
- Type hints throughout
- Consistent error handling patterns
- 90% test coverage ensures safe refactoring

### Improvements Checklist

All critical improvements already implemented by the developer. Future enhancements are optional:

- [x] All 5 tools implemented with LangChain @tool decorator
- [x] Comprehensive error handling for all failure modes
- [x] Phone normalization to E.164 format
- [x] Unit tests with mocked database (23 tests, 90% coverage)
- [x] Integration tests with real PostgreSQL (8 tests)
- [x] Type hints and docstrings throughout
- [ ] **(Future/Optional)** Add caching layer for frequently queried customers
- [ ] **(Future/Optional)** Extract phone normalization to shared utility if used elsewhere
- [ ] **(Future/Optional)** Add E2E tests for concurrent customer operations

### Security Review

**Status:** ✅ PASS - No security concerns identified

**PII Handling:**
- Phone numbers properly normalized to E.164 format
- No phone numbers logged in plaintext (logged in structured extra={} for secure log aggregation)
- Database errors don't expose sensitive customer data

**Input Validation:**
- All inputs validated via Pydantic schemas
- Phone validation prevents invalid formats
- UUID validation prevents injection attacks

**Database Security:**
- FK constraints prevent orphaned references
- Unique constraints prevent duplicate records
- Transaction isolation properly maintained

### Performance Considerations

**Status:** ✅ PASS - No performance concerns identified

**Database Optimization:**
- Phone lookups use indexed column (idx_customers_phone)
- History queries use LIMIT to prevent unbounded results
- Async sessions prevent blocking operations

**Future Optimizations (Optional):**
- Consider Redis caching for frequently queried customers
- Consider connection pooling tuning if high throughput needed

### Risk Coverage

All 7 identified risks have been **fully mitigated** with comprehensive tests:

| Risk ID | Description | Mitigation | Status |
|---------|-------------|------------|--------|
| RISK-001 | Duplicate customer records | Unique constraint + IntegrityError handling | ✅ Mitigated |
| RISK-002 | Phone normalization failure (PII leak) | E.164 normalization + validation tests | ✅ Mitigated |
| RISK-003 | Name update fails silently | Explicit success response + integration test | ✅ Mitigated |
| RISK-004 | Invalid stylist_id assigned | FK constraint + IntegrityError handling | ✅ Mitigated |
| RISK-005 | Database timeout crashes system | SQLAlchemyError exception handling | ✅ Mitigated |
| RISK-006 | Incorrect appointment history order | ORDER BY DESC + ordering verification tests | ✅ Mitigated |
| RISK-007 | Async operations block main thread | Proper async for get_async_session() usage | ✅ Mitigated |

### Files Modified During Review

**None.** No code changes were needed during review.

### Gate Status

**Gate:** ✅ PASS

**Gate File:** `docs/qa/gates/2.1-customer-tools-implementation.yml`

**Quality Score:** 100/100

**Rationale:** All acceptance criteria met with excellent test coverage (90%), comprehensive error handling, full compliance with coding standards, and no blocking issues identified. Implementation is production-ready.

**Test Design:** `docs/qa/assessments/2.1-test-design-20251028.md`

**Risk Assessment:** All 7 risks mitigated (see Risk Coverage section above)

### Recommended Status

**✅ Ready for Done**

**Justification:**
- All 12 acceptance criteria fully implemented and tested
- Code quality is excellent (no refactoring needed)
- 90% test coverage exceeds 85% requirement
- All coding standards followed
- All identified risks mitigated
- No security, performance, or reliability concerns
- Production-ready implementation

**Next Steps:**
1. Story owner can move status to "Done"
2. No additional developer changes required
3. Consider optional future enhancements (caching, shared normalization utility) in separate stories
