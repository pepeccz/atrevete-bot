# Story 2.1: CustomerTools Implementation

## Status

Draft

## Story

**As a** system,
**I want** CustomerTools that provide complete database operations for customer lifecycle management,
**so that** the agent can identify, create, update, and query customer records including name corrections.

## Acceptance Criteria

1. CustomerTools class created in `/agent/tools/customer_tools.py`
2. Tool `get_customer_by_phone(phone: str)` queries database and returns customer or None
3. Tool `create_customer(phone: str, first_name: str, last_name: str = "")` creates new customer
4. Tool `update_customer_name(customer_id: int, first_name: str, last_name: str)` updates name
5. Tool `update_customer_preferences(customer_id: int, preferred_stylist_id: int)` updates preferences
6. Tool `get_customer_history(customer_id: int, limit: int = 5)` returns last N appointments
7. All tools use async SQLAlchemy sessions
8. Tools integrated with LangChain's `@tool` decorator
9. Phone number normalization applied (E.164 format)
10. Error handling: Database failures return graceful error messages
11. Unit tests with mocked database
12. Integration test: Create → query → update → verify persistence

## Tasks / Subtasks

- [ ] **Task 1: Create CustomerTools class structure** (AC: 1, 7, 8)
  - [ ] Create file `agent/tools/customer_tools.py`
  - [ ] Import required dependencies (SQLAlchemy, LangChain, phonenumbers, Pydantic)
  - [ ] Import Customer model from `database/models.py`
  - [ ] Import async session factory from `database/connection.py`
  - [ ] Test: Import verification - no import errors

- [ ] **Task 2: Implement get_customer_by_phone tool** (AC: 2, 7, 8, 9, 10)
  - [ ] Define tool function with `@tool` decorator
  - [ ] Add Pydantic schema for phone parameter validation
  - [ ] Normalize phone to E.164 format using phonenumbers library
  - [ ] Query customers table using async SQLAlchemy session
  - [ ] Return Customer object or None if not found
  - [ ] Add error handling with try-except for database errors
  - [ ] Log queries with conversation context
  - [ ] Test: Unit test with mocked database - verify phone normalization
  - [ ] Test: Unit test - database error returns graceful error message

- [ ] **Task 3: Implement create_customer tool** (AC: 3, 7, 8, 9, 10)
  - [ ] Define tool function with `@tool` decorator
  - [ ] Add Pydantic schema for phone, first_name, last_name parameters
  - [ ] Normalize phone to E.164 format
  - [ ] Create new Customer record with metadata JSONB
  - [ ] Use `async with session.begin()` for transaction
  - [ ] Return created Customer object
  - [ ] Add error handling for duplicate phone (unique constraint)
  - [ ] Log customer creation with customer_id
  - [ ] Test: Unit test - verify customer creation with all fields
  - [ ] Test: Unit test - duplicate phone returns appropriate error

- [ ] **Task 4: Implement update_customer_name tool** (AC: 4, 7, 8, 10)
  - [ ] Define tool function with `@tool` decorator
  - [ ] Add Pydantic schema for customer_id, first_name, last_name
  - [ ] Query customer by UUID
  - [ ] Update first_name and last_name fields
  - [ ] Use `async with session.begin()` for transaction
  - [ ] Return success boolean
  - [ ] Add error handling for non-existent customer_id
  - [ ] Log update operation with customer_id
  - [ ] Test: Unit test - verify name update persists
  - [ ] Test: Unit test - invalid customer_id returns error

- [ ] **Task 5: Implement update_customer_preferences tool** (AC: 5, 7, 8, 10)
  - [ ] Define tool function with `@tool` decorator
  - [ ] Add Pydantic schema for customer_id, preferred_stylist_id
  - [ ] Query customer by UUID
  - [ ] Update preferred_stylist_id (FK to stylists table)
  - [ ] Use `async with session.begin()` for transaction
  - [ ] Return success boolean
  - [ ] Add error handling for invalid stylist_id (FK constraint)
  - [ ] Log preference update with customer_id and stylist_id
  - [ ] Test: Unit test - verify preference update persists
  - [ ] Test: Unit test - invalid stylist_id returns error

- [ ] **Task 6: Implement get_customer_history tool** (AC: 6, 7, 8, 10)
  - [ ] Define tool function with `@tool` decorator
  - [ ] Add Pydantic schema for customer_id, limit (default 5)
  - [ ] Query appointments table filtered by customer_id
  - [ ] Order by start_time DESC (most recent first)
  - [ ] Limit results to N appointments
  - [ ] Include related data: stylist name, service names
  - [ ] Return list of Appointment objects
  - [ ] Add error handling for database query failures
  - [ ] Log history query with customer_id and limit
  - [ ] Test: Unit test - verify correct ordering (most recent first)
  - [ ] Test: Unit test - verify limit parameter works

- [ ] **Task 7: Write unit tests with mocked database** (AC: 11)
  - [ ] Create test file `tests/unit/test_customer_tools.py`
  - [ ] Create pytest fixtures for mocked async SQLAlchemy session
  - [ ] Mock Customer model and query results
  - [ ] Test all 5 tool functions with various scenarios
  - [ ] Test phone normalization edge cases (international formats)
  - [ ] Test error handling for all failure modes
  - [ ] Verify all tests pass with pytest

- [ ] **Task 8: Write integration test for full lifecycle** (AC: 12)
  - [ ] Create test in `tests/integration/test_customer_tools.py`
  - [ ] Use real async PostgreSQL connection (test database)
  - [ ] Test sequence: create_customer → get_customer_by_phone → update_customer_name → verify
  - [ ] Test sequence: create_customer → update_preferences → get_customer_by_phone → verify
  - [ ] Test sequence: create appointment → get_customer_history → verify
  - [ ] Clean up test data after each test (pytest fixtures with cleanup)
  - [ ] Verify all integration tests pass

## Dev Notes

### Previous Story Insights

From Story 1.7 (Complete Type Safety):
- Use proper type annotations for all function signatures
- Handle Optional types with explicit None checks before accessing attributes
- Use TypedDict patterns for complex test fixtures
- All async functions must have proper return type annotations
- Database query results may return None - always check before accessing attributes

### Data Models

**Customer Model** [Source: architecture/data-models.md#4.1]:
```python
# Key attributes from Customer model:
- id: UUID (primary key)
- phone: string (E.164 format, unique, indexed)
- first_name: string
- last_name: string (optional)
- created_at: datetime (Europe/Madrid timezone)
- last_service_date: datetime (nullable)
- preferred_stylist_id: UUID (nullable, FK to stylists)
- total_spent: decimal
- metadata: JSONB (flexible storage)
```

**Database Schema** [Source: architecture/database-schema.md#8.1]:
```sql
CREATE TABLE customers (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    phone VARCHAR(20) NOT NULL UNIQUE,
    first_name VARCHAR(100) NOT NULL,
    last_name VARCHAR(100),
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    last_service_date TIMESTAMP WITH TIME ZONE,
    preferred_stylist_id UUID REFERENCES stylists(id) ON DELETE SET NULL,
    total_spent NUMERIC(10, 2) NOT NULL DEFAULT 0.00,
    metadata JSONB DEFAULT '{}'
);
```

Indexes:
- `idx_customers_phone` - UNIQUE index on phone (for fast lookup)
- `idx_customers_preferred_stylist` - Index on preferred_stylist_id
- `idx_customers_last_service` - Index on last_service_date DESC NULLS LAST

### Component Specifications

**CustomerTools Interface** [Source: architecture/components.md#6.5]:
- `get_customer_by_phone(phone)` → Customer | None
- `create_customer(phone, first_name, last_name="", metadata={})` → Customer
- `update_customer_name(customer_id, first_name, last_name)` → success
- `update_preferences(customer_id, preferred_stylist_id)` → success
- `get_customer_history(customer_id, limit=5)` → List[Appointment]

Dependencies:
- PostgreSQL Customer table
- SQLAlchemy async session
- phonenumbers library for E.164 normalization
- LangChain @tool decorator

Technology Stack [Source: architecture/components.md#6.5]:
- SQLAlchemy 2.0+ async ORM
- Phone number normalization (phonenumbers library)
- LangChain @tool decorator for LLM integration

### File Locations

**Tool File Path** [Source: architecture/unified-project-structure.md]:
- Create: `agent/tools/customer_tools.py`

**Test File Paths** [Source: architecture/unified-project-structure.md]:
- Unit tests: `tests/unit/test_customer_tools.py`
- Integration tests: `tests/integration/test_customer_tools.py`

**Related Files**:
- Database models: `database/models.py` (import Customer model)
- Database connection: `database/connection.py` (import async_session_factory)
- Existing tools reference: `agent/tools/notification_tools.py` (for pattern reference)

### Technical Constraints

**Python Version & Dependencies** [Source: architecture/tech-stack.md#3.1]:
- Python 3.11+ (async/await, type hints)
- SQLAlchemy 2.0+ (async support required)
- LangChain 0.3.0+ (for @tool decorator)
- pytest 8.3.0 + pytest-asyncio 0.24.0 (for testing)
- phonenumbers library (for E.164 normalization)

**Coding Standards** [Source: architecture/coding-standards.md#18.1]:
- **Phone Normalization**: E.164 format via `phonenumbers` library (mandatory)
- **Timezone**: All datetimes use `ZoneInfo("Europe/Madrid")`
- **Database Transactions**: Multi-step operations use `async with session.begin()`
- **Tool Invocation**: Always use LangChain `@tool` decorator with Pydantic validation
- **Error Handling**: All tools use try-except with logging
- **Logging**: Include `customer_id` or `phone` for traceability
- **Environment Variables**: Access via `shared/config.py`, never direct `os.getenv()`

**Naming Conventions** [Source: architecture/coding-standards.md#18.2]:
- Python Functions: snake_case (`get_customer_by_phone`)
- Python Classes: PascalCase (`CustomerTools`)
- Database Tables: snake_case (`customers`)

**Type Safety Requirements** [Source: previous story 1.7]:
- All function signatures must have complete type annotations
- Use `| None` for Optional types (Python 3.11+ syntax)
- Database query results must have None checks before attribute access
- Use `async def` with proper return type annotations

### Testing Requirements

**Testing Strategy** [Source: architecture/testing-strategy.md#15.2]:
- **Unit Tests**: Mock external dependencies (database queries)
- **Integration Tests**: Real async PostgreSQL connection (test database)
- **Test Organization**: Unit tests in `tests/unit/`, integration in `tests/integration/`

**Test Coverage Requirements** [Source: epic 1 stories]:
- Minimum 85% code coverage (as established in Story 1.6)
- All tools must have both unit and integration tests
- Test both success and failure paths

**Testing Patterns** [Source: previous story 1.7]:
- Use pytest fixtures for database setup/teardown
- Mock async SQLAlchemy sessions with `AsyncMock`
- Test database errors with graceful error handling
- Clean up test data after each integration test

**Phone Normalization Test Cases**:
- Spanish mobile: "+34612345678"
- Spanish mobile without +: "612345678" → "+34612345678"
- International format: "+1234567890"
- Invalid phone: return error message

### Architecture Patterns

**Async Database Operations** [Source: architecture/coding-standards.md#18.1]:
```python
from database.connection import async_session_factory

async def example_tool():
    async with async_session_factory() as session:
        async with session.begin():
            # Perform database operations
            result = await session.execute(query)
            await session.commit()  # Automatic with context manager
```

**LangChain Tool Pattern** [Source: architecture/components.md#6.5]:
```python
from langchain.tools import tool
from pydantic import BaseModel, Field

class CustomerPhoneSchema(BaseModel):
    phone: str = Field(description="Customer phone number")

@tool(args_schema=CustomerPhoneSchema)
async def get_customer_by_phone(phone: str) -> dict | None:
    """Get customer by phone number."""
    # Implementation
```

**Error Handling Pattern** [Source: architecture/coding-standards.md#18.1]:
```python
import logging
logger = logging.getLogger(__name__)

try:
    result = await database_operation()
except SQLAlchemyError as e:
    logger.error(f"Database error in get_customer_by_phone: {e}", extra={"phone": phone})
    return {"error": "Failed to retrieve customer", "details": str(e)}
```

### Project Structure Notes

The file path `agent/tools/customer_tools.py` aligns with the defined project structure. The directory `agent/tools/` already exists with `notification_tools.py` as a reference implementation. All imports should follow the established patterns in existing code.

No structural conflicts identified between story requirements and architecture.

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-28 | 1.0 | Story created for Epic 2 | Bob (Scrum Master) |

## Dev Agent Record

*This section will be populated by the development agent during implementation.*

### Agent Model Used

*To be filled by dev agent*

### Debug Log References

*To be filled by dev agent*

### Completion Notes

*To be filled by dev agent*

### File List

*To be filled by dev agent*

## QA Results

*This section will be populated by the QA agent after implementation review.*
