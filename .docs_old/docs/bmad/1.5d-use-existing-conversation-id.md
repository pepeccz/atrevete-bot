# BMAD: Use Existing Conversation ID from Chatwoot Webhook

**Story:** 1.5 - Basic LangGraph State & Echo Bot
**Date:** 2025-10-28
**Severity:** Critical (Blocking outbound messages)
**Status:** ⏳ In Progress

---

## Behavior

### Observed Symptoms

After fixing the URL trailing slash issue (see `1.5c`), the agent still failed to send outbound messages with a persistent 404 error when attempting to create conversations:

**Agent Logs:**
```json
{"timestamp": "2025-10-27T23:46:36.808036+00:00", "level": "INFO", "logger": "__main__", "message": "Outgoing message received: conversation_id=3, phone=+34623226544"}
{"timestamp": "2025-10-27T23:46:36.809225+00:00", "level": "INFO", "logger": "agent.tools.notification_tools", "message": "Sending message to +34623226544"}
{"timestamp": "2025-10-27T23:46:37.083825+00:00", "level": "INFO", "logger": "httpx", "message": "HTTP Request: GET .../contacts/search?q=%2B34623226544 \"HTTP/1.1 200 OK\""}
{"timestamp": "2025-10-27T23:46:37.319099+00:00", "level": "INFO", "logger": "httpx", "message": "HTTP Request: GET .../contacts/243 \"HTTP/1.1 200 OK\""}
{"timestamp": "2025-10-27T23:46:37.390943+00:00", "level": "INFO", "logger": "httpx", "message": "HTTP Request: POST .../conversations \"HTTP/1.1 404 Not Found\""}
{"timestamp": "2025-10-27T23:46:42.352167+00:00", "level": "ERROR", "logger": "agent.tools.notification_tools", "message": "Failed to send message to +34623226544 after retries: Client error '404 Not Found'"}
```

### User Impact

- **Critical:** Messages processed successfully by LangGraph but never delivered to customers
- **Symptoms:** Agent receives webhook with `conversation_id=3`, processes message, generates response, but fails to send via Chatwoot API
- **Root Cause:** Architectural flaw - attempting to CREATE new conversation instead of using existing `conversation_id` from webhook

### Analysis

**Flow Discovery:**

1. Chatwoot sends webhook: `conversation_id=3` (conversation already exists in Chatwoot)
2. Agent receives message, processes successfully through LangGraph
3. Agent publishes to `outgoing_messages` channel with `conversation_id=3`
4. Worker receives message with `conversation_id=3`
5. **Problem:** Worker calls `send_message(phone, message)` WITHOUT `conversation_id`
6. `send_message()` tries to find/create conversation by phone number
7. POST `/conversations` with `source_id` returns 404 (despite manual testing showing it works!)
8. **Real issue:** We should send message DIRECTLY to `conversation_id=3`, not create new conversation

**Key Discovery:**

Manual testing proved POST with source_id returns 200 OK:
```python
$ docker exec atrevete-agent python3 -c "..."
# POST /conversations with source_id → 200 OK
```

But in production flow, it returns 404. Why? Because **we already HAVE the conversation_id** from Chatwoot! We shouldn't be creating conversations at all.

---

## Measure

### Before Fix - Code Analysis

**File:** `agent/tools/notification_tools.py:195-262`

```python
async def send_message(
    self, customer_phone: str, message: str, customer_name: str | None = None
) -> bool:
    """Send message to customer via Chatwoot.

    This method handles the complete flow:
    1. Find or create contact by phone              # ❌ Unnecessary
    2. Get or create conversation for contact        # ❌ Unnecessary
    3. Send message to conversation
    """
    try:
        logger.info(f"Sending message to {customer_phone}")

        # ❌ Find or create contact
        contact = await self._find_contact_by_phone(customer_phone)
        if not contact:
            logger.info(f"Creating new contact for {customer_phone}")
            contact = await self._create_contact(customer_phone, customer_name)

        contact_id = contact.get("id")
        if not contact_id:
            logger.error(f"No contact ID found for {customer_phone}")
            return False

        # ❌ Get or create conversation
        conversation_id = await self._get_or_create_conversation(contact_id)

        # ✅ Send message (this part is correct)
        async with httpx.AsyncClient() as client:
            response = await client.post(
                f"{self.api_url}/api/v1/accounts/{self.account_id}/conversations/{conversation_id}/messages",
                json={"content": message, "message_type": "outgoing", "private": False},
                headers=self.headers,
                timeout=10.0,
            )
            response.raise_for_status()
```

**File:** `agent/main.py:195-210` (subscribe_to_outgoing_messages)

```python
# Parse message JSON
data = json.loads(message["data"])
customer_phone = data.get("customer_phone")
message_text = data.get("message")
conversation_id = data.get("conversation_id", "unknown")  # ✅ We HAVE this!

logger.info(
    f"Outgoing message received: conversation_id={conversation_id}, phone={customer_phone}"
)

# ❌ Send message via Chatwoot WITHOUT conversation_id
success = await chatwoot.send_message(customer_phone, message_text)
#                                     ^^^^^^^^^^^^^^^^^ Missing conversation_id parameter!
```

###Evidence of Problem

**Logs show we have conversation_id but don't use it:**
```
"Outgoing message received: conversation_id=3, phone=+34623226544"
"Sending message to +34623226544"
# Then tries to CREATE conversation instead of using conversation_id=3
"HTTP Request: POST .../conversations \"HTTP/1.1 404 Not Found\""
```

**Manual test proves POST works:**
- When run manually in container: POST /conversations → 200 OK
- When run in production flow: POST /conversations → 404 Not Found
- **Conclusion:** The endpoint WORKS, but we shouldn't be calling it because we already have the conversation_id!

---

## Act

### Solution Implemented

**Strategy:** Modify `send_message()` to accept optional `conversation_id` parameter and use it directly when provided, skipping find/create logic.

**Changes Made:**

**1. File:** `agent/tools/notification_tools.py:195-262`

```python
async def send_message(
    self,
    customer_phone: str,
    message: str,
    customer_name: str | None = None,
    conversation_id: int | None = None,  # ✅ NEW parameter
) -> bool:
    """
    Send message to customer via Chatwoot.

    This method handles the complete flow:
    1. If conversation_id provided, use it directly         # ✅ NEW
    2. Otherwise: Find or create contact by phone
    3. Otherwise: Get or create conversation for contact
    4. Send message to conversation

    Args:
        customer_phone: E.164 formatted phone number
        message: Message text to send
        customer_name: Optional customer name (used when creating new contact)
        conversation_id: Optional existing conversation ID from webhook  # ✅ NEW

    Returns:
        True if message sent successfully, False otherwise
    """
    try:
        logger.info(f"Sending message to {customer_phone}")

        # ✅ If conversation_id provided, use it directly
        if conversation_id is not None:
            logger.info(f"Using existing conversation_id={conversation_id}")
        else:
            # Find or create contact
            contact = await self._find_contact_by_phone(customer_phone)
            if not contact:
                logger.info(f"Creating new contact for {customer_phone}")
                contact = await self._create_contact(customer_phone, customer_name)

            contact_id = contact.get("id")
            if not contact_id:
                logger.error(f"No contact ID found for {customer_phone}")
                return False

            # Get or create conversation
            conversation_id = await self._get_or_create_conversation(contact_id)

        # Send message (unchanged)
        async with httpx.AsyncClient() as client:
            response = await client.post(
                f"{self.api_url}/api/v1/accounts/{self.account_id}/conversations/{conversation_id}/messages",
                json={"content": message, "message_type": "outgoing", "private": False},
                headers=self.headers,
                timeout=10.0,
            )
            response.raise_for_status()

            logger.info(
                f"Message sent successfully to {customer_phone}, conversation_id={conversation_id}"
            )
            return True
```

**2. File:** `agent/main.py:195-212`

```python
# Parse message JSON
data = json.loads(message["data"])
customer_phone = data.get("customer_phone")
message_text = data.get("message")
conversation_id = data.get("conversation_id")  # ✅ Removed default "unknown"

logger.info(
    f"Outgoing message received: conversation_id={conversation_id}, phone={customer_phone}",
    extra={"conversation_id": conversation_id, "customer_phone": customer_phone},
)

# ✅ Send message via Chatwoot WITH conversation_id
success = await chatwoot.send_message(
    customer_phone, message_text, conversation_id=conversation_id
)
```

**Key Changes:**
- ✅ Added optional `conversation_id: int | None = None` parameter to `send_message()`
- ✅ Added conditional logic: if `conversation_id` provided, skip find/create and use directly
- ✅ Updated `main.py` to pass `conversation_id` from webhook data
- ✅ Removed default value `"unknown"` - use None instead to allow type checking

### Deployment

**Attempt 1: Regular build (FAILED)**
```bash
docker compose build agent
docker compose restart agent
# Result: Code NOT updated in container (Docker cache)
```

**Attempt 2: Force rebuild without cache (IN PROGRESS)**
```bash
docker compose build --no-cache agent
# Status: Installing dependencies, ~6 minutes total
```

**After rebuild completes:**
```bash
docker compose restart agent
docker compose logs agent --tail 20
# Verify: "Using existing conversation_id=3" in logs
```

### Expected Validation Results

**After Fix - Logs (expected):**
```json
{"level": "INFO", "message": "Outgoing message received: conversation_id=3, phone=+34623226544"}
{"level": "INFO", "message": "Sending message to +34623226544"}
{"level": "INFO", "message": "Using existing conversation_id=3"}  # ✅ NEW
{"level": "INFO", "message": "HTTP Request: POST .../conversations/3/messages \"HTTP/1.1 200 OK\""}  # ✅ Direct to messages
{"level": "INFO", "message": "Message sent successfully to +34623226544, conversation_id=3"}
```

**No more:**
- ❌ GET /contacts/search
- ❌ GET /contacts/243
- ❌ POST /conversations (404)

**Instead:**
- ✅ Direct POST to /conversations/3/messages

---

## Document

### Lessons Learned

1. **Use Existing Identifiers:** When external systems (like Chatwoot) provide identifiers in webhooks, use them directly instead of recreating them through API calls. This avoids unnecessary round-trips and potential mismatches.

2. **Docker Build Caching Issues:** Regular `docker compose build` may not update files if Docker uses cached layers. Always use `--no-cache` flag for critical code changes, especially when previous builds didn't reflect changes.

3. **Architectural Assumptions:** The original code assumed we needed to find/create conversations for every outbound message. This was correct for scenarios where we initiate conversations, but incorrect for webhook-driven flows where conversations already exist.

4. **Debugging Flow:** Manual testing proved the API endpoint worked (POST /conversations → 200 OK), but this was a red herring. The real issue wasn't the endpoint failing - it was calling the wrong endpoint entirely.

### Knowledge Base

**Pattern:** Webhook-Driven Conversation Handling

**Recommended Implementation:**

```python
class ChatwootClient:
    async def send_message(
        self,
        customer_phone: str,
        message: str,
        customer_name: str | None = None,
        conversation_id: int | None = None,  # NEW: Optional for webhook flows
    ) -> bool:
        """Send message via Chatwoot.

        If conversation_id provided (from webhook), use directly.
        Otherwise, find/create contact and conversation (for agent-initiated messages).
        """
        if conversation_id is not None:
            # Webhook flow: conversation already exists
            return await self._send_to_conversation(conversation_id, message)
        else:
            # Agent-initiated flow: need to find/create
            contact = await self._find_or_create_contact(customer_phone, customer_name)
            conversation_id = await self._get_or_create_conversation(contact["id"])
            return await self._send_to_conversation(conversation_id, message)

    async def _send_to_conversation(self, conversation_id: int, message: str) -> bool:
        """Send message to existing conversation."""
        async with httpx.AsyncClient() as client:
            response = await client.post(
                f"{self.api_url}/api/v1/accounts/{self.account_id}/conversations/{conversation_id}/messages",
                json={"content": message, "message_type": "outgoing", "private": False},
                headers=self.headers,
            )
            response.raise_for_status()
            return True
```

**Benefits:**
- Reduces API calls from 3 (search contact, get contact, create conversation) to 1 (send message)
- Eliminates 404 errors from attempting to create existing conversations
- Faster message delivery (fewer round-trips)
- Clearer separation of webhook vs agent-initiated flows

### Testing Strategy

**Test Cases:**

1. **Webhook Flow (existing conversation):**
   - Input: `conversation_id=3`, `phone="+34623226544"`, `message="Hello"`
   - Expected: Direct POST to `/conversations/3/messages`, 200 OK
   - Verify: No calls to `/contacts/search` or `/conversations` (create)

2. **Agent-Initiated Flow (new conversation):**
   - Input: `phone="+34999999999"`, `message="Reminder"`, `conversation_id=None`
   - Expected: Find/create contact, create conversation, send message
   - Verify: Calls to `/contacts/search`, `/contacts`, `/conversations`, `/conversations/{id}/messages`

3. **Edge Case: Invalid conversation_id:**
   - Input: `conversation_id=999999` (doesn't exist), `message="Test"`
   - Expected: 404 error from `/conversations/999999/messages`
   - Behavior: Error logged, return False (handled by retry logic)

### Related Issues

- **Issue 1.5a:** AsyncRedisSaver async context manager pattern
- **Issue 1.5b:** Redis Stack requirement (RedisSearch)
- **Issue 1.5c:** Chatwoot API URL trailing slash fix
- **Story 1.4:** FastAPI Webhook Receiver (provides conversation_id)
- **Story 1.5 AC #11:** Manual test with real WhatsApp message (pending after this fix)

### Prevention

**Code Review Checklist:**
- [ ] When receiving webhooks with identifiers, verify those IDs are used directly
- [ ] Don't recreate resources that webhooks already reference
- [ ] Verify Docker builds with `--no-cache` for critical changes
- [ ] Test both webhook-driven and agent-initiated flows separately

**Future Enhancements:**

1. **Metrics Tracking:**
   ```python
   if conversation_id is not None:
       metrics.increment("chatwoot.message.webhook_flow")
   else:
       metrics.increment("chatwoot.message.agent_initiated")
   ```

2. **Validation:**
   ```python
   # Optionally validate conversation exists before sending
   if conversation_id is not None and VALIDATE_CONVERSATIONS:
       exists = await self._conversation_exists(conversation_id)
       if not exists:
           logger.warning(f"Conversation {conversation_id} not found, falling back to find/create")
           conversation_id = None  # Fall back to find/create flow
   ```

---

**Resolution Time:** ~2 hours (discovery, implementation, multiple build attempts)
**Related Files:**
- `agent/tools/notification_tools.py:195-262`
- `agent/main.py:195-212`

**Impact:** Critical - Blocks ALL outbound message delivery
**Downstream Dependencies:** Requires successful --no-cache build, then manual test to validate

**References:**
- Chatwoot API: POST `/conversations/{id}/messages`
- Story 1.5 AC #11: Manual test with real WhatsApp message
- Docker best practices: `--no-cache` flag for dependency/code changes
