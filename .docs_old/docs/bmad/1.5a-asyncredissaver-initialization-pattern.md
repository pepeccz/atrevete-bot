# BMAD: AsyncRedisSaver Initialization Pattern Fix

**Story:** 1.5 - Basic LangGraph State & Echo Bot
**Date:** 2025-10-28
**Severity:** Critical (Blocking)
**Status:** ✅ Resolved

---

## Behavior

### Observed Symptoms

After deploying the LangGraph agent with Redis checkpointing (Story 1.5), the agent failed to initialize properly:

**Agent Logs:**
```
{"timestamp": "2025-10-27T22:47:11.959074+00:00", "level": "INFO", "logger": "agent.state.checkpointer", "message": "Creating Redis checkpointer with URL: redis://redis:6379/0"}
{"timestamp": "2025-10-27T22:47:22.552022+00:00", "level": "INFO", "logger": "agent.tools.notification_tools", "message": "ChatwootClient initialized: https://..."}
{"timestamp": "2025-10-27T22:47:22.552244+00:00", "level": "INFO", "logger": "__main__", "message": "Subscribing to 'outgoing_messages' channel..."}
{"timestamp": "2025-10-27T22:47:22.557546+00:00", "level": "INFO", "logger": "__main__", "message": "Subscribed to 'outgoing_messages' channel"}
```

**Missing Expected Logs:**
- ❌ "Redis checkpointer created successfully"
- ❌ "Conversation graph compiled with checkpointer=enabled"
- ❌ "Subscribing to 'incoming_messages' channel"
- ❌ "Subscribed to 'incoming_messages' channel"

**Behavior:** The agent started but hung indefinitely during checkpointer initialization. The `subscribe_to_incoming_messages()` worker never completed initialization, preventing message processing.

### User Impact

- **Critical:** Agent unable to process WhatsApp messages
- **Symptoms:** Messages sent to Chatwoot webhook were successfully received by API and published to Redis `incoming_messages` channel, but never processed by agent
- **Duration:** Blocking issue discovered during Story 1.5 manual testing

### Root Cause Analysis

Investigation using direct Python testing inside the agent container revealed:

```python
# Test 1: Direct instantiation (INCORRECT - what we were doing)
from langgraph.checkpoint.redis.aio import AsyncRedisSaver
from redis.asyncio import Redis

redis_client = Redis.from_url('redis://redis:6379/0', decode_responses=False)
checkpointer = AsyncRedisSaver(redis_client)  # ❌ Hangs forever
```

**Root Cause:** `AsyncRedisSaver` requires async initialization via context manager pattern. Direct instantiation creates an uninitialized object that blocks on first access.

**LangGraph Documentation Pattern (Correct):**
```python
async with AsyncRedisSaver.from_conn_string(DB_URI) as checkpointer:
    # await checkpointer.asetup()  # Called automatically by context manager
    graph = builder.compile(checkpointer=checkpointer)
```

---

## Measure

### Before Fix - Code Analysis

**File:** `agent/state/checkpointer.py`

```python
def get_redis_checkpointer() -> BaseCheckpointSaver[Any]:
    """Get Redis checkpointer instance."""
    settings = get_settings()
    redis_url = settings.REDIS_URL

    logger.info(f"Creating Redis checkpointer with URL: {redis_url}")

    # ❌ INCORRECT: Direct instantiation without async setup
    redis_client = Redis.from_url(redis_url, decode_responses=False)
    checkpointer = AsyncRedisSaver(redis_client)

    logger.info("Redis checkpointer created successfully")  # Never reached
    return checkpointer
```

**File:** `agent/main.py` (subscribe_to_incoming_messages)

```python
async def subscribe_to_incoming_messages():
    client = get_redis_client()
    checkpointer = get_redis_checkpointer()  # ❌ Hangs here
    graph = create_conversation_graph(checkpointer=checkpointer)
    # ... rest never executes
```

### Evidence of Hanging Behavior

**Test Output (container exec):**
```bash
$ docker exec atrevete-agent python3 -c "
import asyncio
from langgraph.checkpoint.redis.aio import AsyncRedisSaver

async def test():
    print('Attempting AsyncRedisSaver.from_conn_string...')
    async with AsyncRedisSaver.from_conn_string('redis://redis:6379/0') as saver:
        print('✓ AsyncRedisSaver initialized successfully')

asyncio.run(test())
"

# Output:
Attempting AsyncRedisSaver.from_conn_string...
✗ AsyncRedisSaver failed: unknown command 'FT._LIST'
```

This test also revealed a secondary issue (see `1.5b-redis-stack-requirement.md`).

---

## Act

### Solution Implemented

**Strategy:** Adopt LangGraph's documented async context manager pattern for `AsyncRedisSaver`.

**Changes Made:**

1. **Removed synchronous checkpointer factory** (`agent/state/checkpointer.py`)
2. **Integrated checkpointer initialization directly into subscriber** (`agent/main.py`)

**File:** `agent/main.py:46-58` (subscribe_to_incoming_messages)

```python
async def subscribe_to_incoming_messages():
    """Subscribe to incoming_messages Redis channel and process with LangGraph."""
    from langgraph.checkpoint.redis.aio import AsyncRedisSaver
    from shared.config import get_settings

    client = get_redis_client()
    settings = get_settings()

    logger.info(f"Initializing AsyncRedisSaver with URL: {settings.REDIS_URL}")

    # ✅ CORRECT: Async context manager pattern
    async with AsyncRedisSaver.from_conn_string(settings.REDIS_URL) as checkpointer:
        logger.info("AsyncRedisSaver initialized successfully")

        graph = create_conversation_graph(checkpointer=checkpointer)

        logger.info("Subscribing to 'incoming_messages' channel...")

        # Subscribe to channel
        pubsub = client.pubsub()
        await pubsub.subscribe("incoming_messages")

        logger.info("Subscribed to 'incoming_messages' channel")

        try:
            async for message in pubsub.listen():
                # ... message processing (moved inside context manager)
```

**Key Changes:**
- ✅ Use `async with AsyncRedisSaver.from_conn_string()` instead of direct instantiation
- ✅ Move all message processing logic **inside** the context manager scope
- ✅ Checkpointer lifecycle managed by context manager (automatic setup/teardown)
- ✅ Import moved to function scope to avoid circular dependencies

### Deployment

```bash
# Rebuild agent with fix
docker compose build agent

# Deploy updated agent
docker compose up -d agent

# Verify logs
docker compose logs agent --tail 30
```

### Validation Results

**After Fix - Logs:**
```json
{"timestamp": "2025-10-27T23:01:01.698893+00:00", "level": "INFO", "logger": "__main__", "message": "Initializing AsyncRedisSaver with URL: redis://redis:6379/0"}
{"timestamp": "2025-10-27T23:01:01.721684+00:00", "level": "INFO", "logger": "langgraph.checkpoint.redis.aio", "message": "Redis client is a standalone client"}
{"timestamp": "2025-10-27T23:01:01.723374+00:00", "level": "INFO", "logger": "__main__", "message": "AsyncRedisSaver initialized successfully"}
{"timestamp": "2025-10-27T23:01:01.729940+00:00", "level": "INFO", "logger": "agent.graphs.conversation_flow", "message": "Conversation graph compiled with checkpointer=enabled"}
{"timestamp": "2025-10-27T23:01:01.730221+00:00", "level": "INFO", "logger": "__main__", "message": "Subscribing to 'incoming_messages' channel..."}
{"timestamp": "2025-10-27T23:01:01.735040+00:00", "level": "INFO", "logger": "__main__", "message": "Subscribed to 'incoming_messages' channel"}
```

✅ **All expected initialization steps completed successfully**

---

## Document

### Lessons Learned

1. **LangGraph Checkpointer Lifecycle:** `AsyncRedisSaver` requires async setup via context manager. Direct instantiation creates an uninitialized object.

2. **Async Resource Management:** When using async resources in Python, always follow the documented patterns. The `async with` pattern ensures proper setup (`asetup()`) and teardown (`aclose()`).

3. **Context Manager Scope:** All code that uses the checkpointer must be inside the `async with` block. Moving the entire message processing loop inside the context ensures the checkpointer remains valid.

4. **Testing Async Code:** Direct container testing (`docker exec`) was crucial for isolating the issue from the full application stack.

### Knowledge Base

**Pattern:** LangGraph Redis Checkpointing

**Correct Implementation:**
```python
from langgraph.checkpoint.redis.aio import AsyncRedisSaver

async with AsyncRedisSaver.from_conn_string(redis_url) as checkpointer:
    # checkpointer.asetup() called automatically here
    graph = create_graph(checkpointer=checkpointer)

    # Use graph for message processing
    result = await graph.ainvoke(state, config=config)

    # checkpointer.aclose() called automatically on exit
```

**Incorrect Implementation (will hang):**
```python
from redis.asyncio import Redis
from langgraph.checkpoint.redis.aio import AsyncRedisSaver

redis_client = Redis.from_url(redis_url)
checkpointer = AsyncRedisSaver(redis_client)  # ❌ Not initialized
graph = create_graph(checkpointer=checkpointer)  # ❌ Will hang
```

### Related Issues

- **Issue 1.5b:** Redis Stack requirement (FT._LIST command) - see `1.5b-redis-stack-requirement.md`
- **Story 1.5 AC #9:** Checkpointing verified with crash recovery (pending manual test)

### Prevention

**Code Review Checklist:**
- [ ] All `AsyncRedisSaver` instantiations use `async with from_conn_string()` pattern
- [ ] No direct `AsyncRedisSaver(redis_client)` instantiations
- [ ] All checkpointer usage is within the context manager scope
- [ ] Initialization logs confirm checkpointer setup completion

**Future Improvements:**
- Consider adding a startup health check that validates checkpointer initialization
- Add integration test that verifies checkpointer initialization before message processing
- Document async context manager pattern in project's architecture documentation

---

**Resolution Time:** ~2 hours (including discovery, testing, fix implementation, validation)
**Related Files:** `agent/main.py`, `agent/state/checkpointer.py` (deprecated)
**References:**
- LangGraph AsyncRedisSaver documentation
- Web search results for "LangGraph AsyncRedisSaver initialization example 2025"
