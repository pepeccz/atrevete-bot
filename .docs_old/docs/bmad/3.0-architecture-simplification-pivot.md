# BMAD 3.0: Architecture Simplification Pivot
## Hybrid Conversational + Transactional Architecture

**Date:** 2025-10-30
**Author:** Sarah (Product Owner Agent)
**Category:** Architecture
**Impact:** Major (affects Epic 2-3 implementation, Epic 4-7 design)
**Status:** APPROVED - IMPLEMENTATION IN PROGRESS

---

## Behavior: What Changed and Why

### Original Architecture (Epic 1-3 as implemented)

**Design Philosophy:**
> "Explicit state machine control for all conversational scenarios via LangGraph nodes"

**Implementation:**
- 25 LangGraph nodes for orchestrating conversations
- 158 ConversationState fields tracking all conversational decisions
- 13 nodes dedicated to conversational flows (greetings, FAQs, inquiries)
- 10+ "awaiting_*" state flags requiring priority-based routing
- Topic change detection as escape mechanism

**Rationale (Original):**
- Belief that all conversations needed structured control
- Desire for predictability and testability
- Concern about LLM unpredictability without explicit guards

---

### New Architecture (Post-Pivot)

**Design Philosophy:**
> "Strict control for transactions, conversational freedom for information"

**Implementation:**

**Tier 1: Conversational Agent (New)**
- Single `conversational_agent` node powered by Claude
- Access to 8 tools (customer, FAQ, services, availability, pack, consultation)
- Claude decides conversational flow based on context
- Minimal state tracking (customer context only)

**Tier 2: Transactional Flow (Preserved)**
- 6 LangGraph nodes for booking, payment, modification, cancellation
- Comprehensive state tracking (50 fields: booking context)
- Explicit validation and routing
- Atomic transaction guarantees

**Transition Point:**
- When customer expresses booking intent ‚Üí hand off from Tier 1 ‚Üí Tier 2
- Claude detects intent, sets `booking_intent_confirmed=True`
- LangGraph conditional edge routes to `validate_booking_request`

---

### Why the Change?

**Trigger:** User (Pepe) concern about over-complexity preventing natural responses

**Evidence of Problem:**

1. **Routing Complexity:**
   - `route_entry()` function: 65 lines, 10 conditional checks
   - Every new conversational flow required 3-5 new nodes
   - State explosion: 30+ fields just for tracking conversational state

2. **Rigidity Symptoms:**
   - Bot "trapped" in awaiting states when customer changes topic
   - Needed "topic change detection" escape hatches (code smell)
   - Unnatural responses: "I'm waiting for your pack response" instead of flexible conversation

3. **Maintenance Burden:**
   - `conversation_flow.py`: 710 lines, 25 nodes, nested conditionals
   - Adding FAQ required 3 nodes: detect ‚Üí fetch ‚Üí answer
   - Tests required mocking 158 state fields

**User Insight:**
> "El bot se pierde en ciertas consultas porque de tanto control no es capaz de entender la consulta o de procesarla correctamente y responder de manera personalizada, humana"

**Root Cause Analysis:**
- ‚ùå **Incorrect Assumption:** "All conversations need state machine control"
- ‚úÖ **Reality:** Only transactional flows need strict control
- ‚ùå **Over-Engineering:** Conversational logic better handled by LLM reasoning

---

## Measure: Impact Quantification

### Code Complexity Reduction

| Metric | Before | After | Change |
|--------|--------|-------|--------|
| **conversation_flow.py** | 710 lines | ~200 lines | -72% |
| **LangGraph nodes** | 25 nodes | 12 nodes | -52% |
| **Conversational nodes** | 13 nodes | 1 node | -92% |
| **ConversationState fields** | 158 fields | 50 fields | -68% |
| **Awaiting state flags** | 10 flags | 0 flags | -100% |
| **Route entry checks** | 10 checks | 2 checks | -80% |

### File Changes

**Deleted:**
- `agent/nodes/greeting.py` (-50 lines)
- `agent/nodes/faq.py` (-150 lines)
- Parts of `agent/nodes/identification.py` (-100 lines)
- Parts of `agent/nodes/classification.py` (-200 lines)

**Created:**
- `agent/nodes/conversational_agent.py` (+150 lines)
- `agent/tools/availability_tools.py` (+80 lines)
- `agent/tools/pack_tools.py` (+60 lines)

**Modified:**
- `agent/graphs/conversation_flow.py` (710 ‚Üí 200 lines)
- `agent/state/schemas.py` (158 ‚Üí 50 fields)
- `agent/prompts/maite_system_prompt.md` (+200 lines guidance)

**Net Change:** -500 lines of code

---

### Epic Impact

| Epic | Stories Affected | Impact Type | Effort |
|------|------------------|-------------|--------|
| **Epic 1** | 0/6 | None | 0 days |
| **Epic 2** | 3/6 (2.2, 2.3, 2.6) | Rewrite stories | 0.5 days |
| **Epic 3** | 3/6 (3.3, 3.4, 3.5) | Rewrite stories | 0.5 days |
| **Epic 4** | 0/9 | Entry point only | 0.5 days |
| **Epic 5** | 1/5 (5.5 "lo de siempre") | Simplify detection | 0.5 days |
| **Epic 6** | 2/6 (6.3, 6.5 escalation) | Simplify detection | 0.5 days |
| **Epic 7** | 1/7 (7.1 integration tests) | Rewrite tests | 1 day |

**Total Effort:** 4 days (story rewrites + tests)

---

### Test Impact

**Before:**
```python
# Test had to mock 158 state fields
state = {
    "conversation_id": "test-123",
    "customer_phone": "+34612345678",
    "awaiting_name_confirmation": False,
    "awaiting_category_choice": False,
    "consultation_offered": False,
    "consultation_accepted": None,
    "indecision_detected": False,
    "confidence": 0.0,
    # ... 150 more fields
}
```

**After:**
```python
# Test mocks minimal state + tool calls
state = {
    "conversation_id": "test-123",
    "customer_phone": "+34612345678",
    "customer_id": uuid4(),
    "customer_name": "Mar√≠a",
}

# Mock tool calls instead of state
mock_get_faqs.return_value = [...]
mock_check_availability.return_value = [...]
```

**Result:** Tests are simpler, more focused, easier to maintain

---

## Act: Implementation Strategy

### Phase 1: Conversational Agent Creation (2 days)

**1.1 Create Core Node**

File: `agent/nodes/conversational_agent.py`

```python
async def conversational_agent(state: ConversationState) -> dict[str, Any]:
    """
    Single conversational node powered by Claude with tool access.

    Handles: FAQs, greetings, service inquiries, indecision detection
    Tools: get_customer, create_customer, get_faqs, get_services,
           check_availability, suggest_pack, offer_consultation, escalate

    Transition: Sets booking_intent_confirmed=True when customer ready to book
    """
    # Load system prompt with conversational guidance
    system_prompt = get_maite_system_prompt()

    # Prepare tools
    tools = [
        get_customer_by_phone,
        create_customer,
        get_faqs,
        get_services,
        check_availability_tool,  # NEW
        suggest_pack_tool,        # NEW
        offer_consultation_tool,  # NEW
        escalate_to_human,
    ]

    # Create LLM with tools
    llm = ChatAnthropic(model="claude-sonnet-4-20250514")
    llm_with_tools = llm.bind_tools(tools)

    # Format messages
    messages = format_llm_messages_with_summary(state, system_prompt)

    # Invoke LLM
    response = await llm_with_tools.ainvoke(messages)

    # Detect booking intent transition
    booking_intent_confirmed = detect_booking_intent(response)

    # Update state
    return {
        "messages": state["messages"] + [response],
        "booking_intent_confirmed": booking_intent_confirmed,
        "updated_at": datetime.now(ZoneInfo("Europe/Madrid"))
    }
```

**1.2 Convert Nodes to Tools**

**Tool 1: check_availability_tool**
```python
@tool
async def check_availability_tool(
    service_category: str,
    date: str,
    time_range: str | None = None,
    stylist_id: str | None = None
) -> dict[str, Any]:
    """
    Check availability across multiple stylist calendars.

    Args:
        service_category: "Hairdressing" or "Aesthetics"
        date: Date in YYYY-MM-DD format
        time_range: Optional range like "morning", "afternoon", or "14:00-18:00"
        stylist_id: Optional specific stylist UUID

    Returns:
        {
            "available_slots": [
                {"time": "14:00", "stylist_name": "Marta", "stylist_id": "..."},
                {"time": "16:00", "stylist_name": "Pilar", "stylist_id": "..."}
            ],
            "is_same_day": bool,
            "holiday_detected": bool
        }
    """
    # Reuse logic from old check_availability node
    from agent.tools.calendar_tools import CalendarTools

    calendar_tools = CalendarTools()
    slots = await calendar_tools.get_availability(
        service_category, date, time_range, stylist_id
    )

    return {
        "available_slots": slots,
        "is_same_day": is_same_day_booking(date),
        "holiday_detected": any(s.get("holiday") for s in slots)
    }
```

**Tool 2: suggest_pack_tool**
```python
@tool
async def suggest_pack_tool(service_ids: list[str]) -> dict[str, Any]:
    """
    Find money-saving packs for requested services.

    Args:
        service_ids: List of service UUIDs customer requested

    Returns:
        {
            "pack_found": bool,
            "pack_name": str,
            "pack_price": float,
            "individual_price": float,
            "savings": float,
            "pack_id": str
        }
    """
    from agent.tools.booking_tools import get_packs_for_services

    packs = await get_packs_for_services(service_ids)

    if not packs:
        return {"pack_found": False}

    # Select best pack (highest savings)
    best_pack = max(packs, key=lambda p: p.savings_amount)

    return {
        "pack_found": True,
        "pack_name": best_pack.name,
        "pack_price": float(best_pack.price_euros),
        "individual_price": float(best_pack.individual_total),
        "savings": float(best_pack.savings_amount),
        "pack_id": str(best_pack.id)
    }
```

**Tool 3: offer_consultation_tool**
```python
@tool
async def offer_consultation_tool(reason: str) -> dict[str, Any]:
    """
    Offer free 15-minute consultation when customer is indecisive.

    Args:
        reason: Why consultation is being offered (e.g., "comparing_services")

    Returns:
        {
            "consultation_service_id": str,
            "duration_minutes": int,
            "price_euros": float,
            "description": str
        }
    """
    from agent.tools.booking_tools import get_service_by_name

    consultation = await get_service_by_name("CONSULTA GRATUITA", fuzzy=False)

    if not consultation:
        raise ValueError("CONSULTA GRATUITA service not found in database")

    return {
        "consultation_service_id": str(consultation.id),
        "duration_minutes": consultation.duration_minutes,
        "price_euros": float(consultation.price_euros),
        "description": consultation.description
    }
```

**1.3 Expand System Prompt**

File: `agent/prompts/maite_system_prompt.md`

Add section:
```markdown
## Tool Usage Guidelines

### When to Use Tools

**get_customer_by_phone(phone)**
- Use at conversation start to identify new vs returning customers
- Use when customer mentions they've visited before

**get_faqs()**
- Use when customer asks about hours, location, parking, policies
- Questions about "cu√°ndo abr√≠s", "d√≥nde est√°is", "hay parking"

**get_services(category=None)**
- Use when customer asks "qu√© servicios ten√©is"
- Use when customer mentions a service you're unsure exists
- Always use before suggesting specific services

**check_availability_tool(service_category, date, time_range)**
- Use when customer asks "cu√°ndo ten√©is libre"
- Use after customer chooses service and wants to book
- IMPORTANT: Only call after customer has shown booking intent

**suggest_pack_tool(service_ids)**
- Use when customer requests multiple services that might have a pack
- Example: Customer wants "mechas + corte" ‚Üí check for pack first
- Present savings clearly: "Tenemos pack por 80‚Ç¨ vs 90‚Ç¨ individual"

**offer_consultation_tool(reason)**
- Use when customer is indecisive: "no s√© cu√°l elegir", "¬øcu√°l recomiendas?"
- Use when comparing services: "¬ødiferencia entre mechas y balayage?"
- Offer consultation naturally in conversation, don't force it

**escalate_to_human(reason)**
- Medical queries: pregnancy, allergies, skin conditions
- Payment issues after 2 failed attempts
- Customer frustrated or requests human
- You're unsure how to help after 3 clarification attempts

### Booking Intent Detection

**Transition to Transactional Flow:**

When customer shows CLEAR booking intent, set `booking_intent_confirmed=True`:

**Clear Intent Signals:**
- "Quiero reservar [service]"
- "Dame cita para [date]"
- "Reserva [service] para [day]"
- Customer confirms specific time slot after availability check

**NOT Clear Intent:**
- "¬øCu√°nto cuesta?" (inquiry, not booking)
- "¬øTen√©is libre ma√±ana?" (checking, not confirming)
- "Me interesa [service]" (interested, not committing)

**Conversational Flow:**
1. Answer questions naturally using tools
2. Offer options when customer expresses interest
3. ONLY transition to booking when customer explicitly confirms

### Personality in Tool Responses

Even when using tools, maintain Maite's warm personality:

‚ùå ROBOTIC:
"He consultado la base de datos. Tenemos disponibilidad a las 14:00 con Marta."

‚úÖ NATURAL:
"¬°Perfecto! üòä Ma√±ana tenemos libre a las 14:00 con Marta o a las 16:00 con Pilar. ¬øCu√°l prefieres?"

‚ùå FORMAL:
"Seg√∫n la pol√≠tica de cancelaci√≥n, debe cancelar con 24 horas de antelaci√≥n."

‚úÖ FRIENDLY:
"Recuerda que si necesitas cancelar, hazlo con 24 horas de antelaci√≥n para que podamos devolverte el anticipo üíï"
```

---

### Phase 2: State Schema Simplification (1 day)

**2.1 Update ConversationState**

File: `agent/state/schemas.py`

**Before (158 fields):**
```python
class ConversationState(TypedDict, total=False):
    # Core (10 fields) ‚úÖ KEEP
    conversation_id: str
    customer_phone: str
    customer_name: str | None
    messages: list[dict]
    current_intent: str | None
    metadata: dict
    created_at: datetime
    updated_at: datetime
    last_node: str | None
    error_count: int

    # Customer context (10 fields) ‚úÖ KEEP
    customer_id: UUID | None
    is_returning_customer: bool
    customer_history: list[dict]
    preferred_stylist_id: UUID | None
    conversation_summary: str | None
    total_message_count: int
    # ...

    # Conversational tracking (30 fields) ‚ùå DELETE
    awaiting_name_confirmation: bool
    awaiting_category_choice: bool
    consultation_offered: bool
    consultation_accepted: bool
    consultation_declined: bool
    indecision_detected: bool
    confidence: float
    indecision_type: str
    detected_services: list[str]
    faq_detected: bool
    detected_faq_ids: list[str]
    query_complexity: str
    topic_changed_during_pack_response: bool
    topic_changed_during_consultation_response: bool
    clarification_attempts: int
    # ... 15 more

    # Booking context (30 fields) ‚úÖ KEEP
    requested_services: list[UUID]
    requested_date: str | None
    provisional_appointment_id: UUID | None
    payment_link_url: str | None
    booking_validation_passed: bool
    mixed_category_detected: bool
    # ... 24 more
```

**After (50 fields):**
```python
class ConversationState(TypedDict, total=False):
    # Core (10 fields) ‚úÖ
    conversation_id: str
    customer_phone: str
    customer_name: str | None
    messages: list[dict]
    current_intent: str | None
    metadata: dict
    created_at: datetime
    updated_at: datetime
    last_node: str | None
    error_count: int

    # Customer context (10 fields) ‚úÖ
    customer_id: UUID | None
    is_returning_customer: bool
    customer_history: list[dict]
    preferred_stylist_id: UUID | None
    conversation_summary: str | None
    total_message_count: int

    # Booking context (30 fields) ‚úÖ
    booking_intent_confirmed: bool  # NEW - transition flag
    requested_services: list[UUID]
    requested_date: str | None
    requested_time: str | None
    provisional_appointment_id: UUID | None
    payment_link_url: str | None
    booking_validation_passed: bool
    mixed_category_detected: bool
    is_same_day: bool
    available_slots: list[dict]
    # ... 20 more booking-specific
```

**Migration Script:**
```python
# Remove references to deleted fields in all nodes
DELETED_FIELDS = [
    "awaiting_name_confirmation",
    "awaiting_category_choice",
    "consultation_offered",
    "consultation_accepted",
    "consultation_declined",
    "indecision_detected",
    "confidence",
    "indecision_type",
    "detected_services",
    "faq_detected",
    "detected_faq_ids",
    "query_complexity",
    "topic_changed_during_pack_response",
    "topic_changed_during_consultation_response",
    # ... all 30 conversational tracking fields
]

# Grep for usage:
for field in DELETED_FIELDS:
    subprocess.run(["grep", "-r", field, "agent/"])
    # Remove all references
```

---

### Phase 3: LangGraph Refactoring (1 day)

**3.1 Simplify conversation_flow.py**

**Before (710 lines, 25 nodes):**
```python
# 13 conversational nodes
graph.add_node("greet_customer", greet_customer)
graph.add_node("identify_customer", identify_customer)
graph.add_node("greet_new_customer", greet_new_customer)
graph.add_node("confirm_name", confirm_name)
graph.add_node("greet_returning_customer", greet_returning_customer)
graph.add_node("extract_intent", extract_intent)
graph.add_node("detect_faq_intent", detect_faq_intent)
graph.add_node("answer_faq", answer_faq)
graph.add_node("generate_faq_response", generate_personalized_faq_response)
graph.add_node("detect_indecision", detect_indecision)
graph.add_node("offer_consultation", offer_consultation)
graph.add_node("handle_consultation_response", handle_consultation_response)
graph.add_node("handle_service_inquiry", handle_service_inquiry)

# 6 transactional nodes
graph.add_node("validate_booking_request", validate_booking_request)
graph.add_node("check_availability", check_availability)
graph.add_node("suggest_pack", suggest_pack)
graph.add_node("handle_pack_response", handle_pack_response)
# ...

# Complex routing
def route_entry(state):
    if state.get("awaiting_name_confirmation"):
        return "confirm_name"
    if state.get("awaiting_category_choice"):
        return "handle_category_choice"
    # ... 8 more checks
```

**After (~200 lines, 12 nodes):**
```python
# 1 conversational node
graph.add_node("conversational_agent", conversational_agent)

# 6 transactional nodes (preserved)
graph.add_node("validate_booking_request", validate_booking_request)
graph.add_node("create_provisional_booking", create_provisional_booking)
graph.add_node("process_payment_confirmation", process_payment_confirmation)
graph.add_node("confirm_booking", confirm_booking)
graph.add_node("handle_modification", handle_modification)
graph.add_node("handle_cancellation", handle_cancellation)

# Simple entry routing
def route_entry(state):
    # If in transactional flow, resume there
    if state.get("provisional_appointment_id"):
        return "process_payment_confirmation"

    # Otherwise, start with conversational agent
    return "conversational_agent"

graph.set_conditional_entry_point(
    route_entry,
    {
        "conversational_agent": "conversational_agent",
        "process_payment_confirmation": "process_payment_confirmation"
    }
)

# Transition from conversational ‚Üí transactional
def route_from_conversational(state):
    if state.get("booking_intent_confirmed"):
        return "validate_booking_request"
    else:
        return END

graph.add_conditional_edges(
    "conversational_agent",
    route_from_conversational,
    {
        "validate_booking_request": "validate_booking_request",
        END: END
    }
)

# Transactional flow routing (unchanged)
graph.add_edge("validate_booking_request", "create_provisional_booking")
graph.add_edge("create_provisional_booking", "process_payment_confirmation")
# ...
```

**3.2 Delete Obsolete Files**
```bash
rm agent/nodes/greeting.py
rm agent/nodes/faq.py
# Keep identification.py but remove greet_new_customer, confirm_name functions
# Keep classification.py but remove extract_intent, detect_indecision functions
```

---

### Phase 4: Test Refactoring (1 day)

**4.1 Update Integration Tests**

**Before: `tests/integration/scenarios/test_scenario_01_new_booking.py`**
```python
async def test_scenario_01_new_customer_booking():
    # Setup complex state
    state = {
        "conversation_id": "test-123",
        "customer_phone": "+34612345678",
        "messages": [],
        "awaiting_name_confirmation": False,
        "customer_identified": False,
        "indecision_detected": False,
        "consultation_offered": False,
        # ... 150 more fields
    }

    # Invoke multiple nodes sequentially
    result1 = await greet_customer(state)
    result2 = await identify_customer(result1)
    result3 = await greet_new_customer(result2)
    # ... 10 more node invocations
```

**After: `tests/integration/scenarios/test_scenario_01_new_booking.py`**
```python
async def test_scenario_01_new_customer_booking(mocker):
    # Setup minimal state
    state = {
        "conversation_id": "test-123",
        "customer_phone": "+34612345678",
        "messages": [
            HumanMessage(content="Hola, quiero reservar mechas para ma√±ana")
        ],
    }

    # Mock tools
    mock_get_customer = mocker.patch("agent.tools.customer_tools.get_customer_by_phone")
    mock_get_customer.return_value = None  # New customer

    mock_create_customer = mocker.patch("agent.tools.customer_tools.create_customer")
    mock_create_customer.return_value = Customer(...)

    mock_check_availability = mocker.patch("agent.tools.availability_tools.check_availability_tool")
    mock_check_availability.return_value = {
        "available_slots": [
            {"time": "14:00", "stylist_name": "Marta"},
            {"time": "16:00", "stylist_name": "Pilar"}
        ]
    }

    # Invoke conversational agent (single call)
    result = await conversational_agent(state)

    # Verify tool calls
    assert mock_get_customer.called
    assert mock_create_customer.called
    assert mock_check_availability.called

    # Verify response is natural and includes availability
    response = result["messages"][-1].content
    assert "14:00" in response
    assert "Marta" in response
    assert "üå∏" in response  # Maite emoji
```

**Result:** Tests are simpler, focus on tool interactions, easier to maintain

---

### Phase 5: Documentation Update (1 day)

**5.1 Architecture Document Updates**

See detailed changes in:
- Section 2.5: Architectural Patterns (add Hybrid Pattern)
- Section 6.2: Components (split into Conversational + Transactional)
- Section 10.1: ConversationState Schema (update to 50 fields)

**5.2 PRD Update**

Section 3.2 clarification added (see Sprint Change Proposal)

**5.3 Story Rewrites**

Stories 2.2, 2.3, 2.6, 3.3, 3.4, 3.5 rewritten with new ACs

---

## Document: Deviations from Original Plan

### Original Plan (PRD Epic 2-3)

**Epic 2: Customer Identification & Conversational Foundation**
- Story 2.2: Separate `greet_new_customer` + `confirm_name` nodes
- Story 2.3: Separate `greet_returning_customer` + `extract_intent` nodes
- Story 2.6: Separate `detect_faq_intent` + `answer_faq` nodes

**Epic 3: Service Discovery & Calendar Availability**
- Story 3.3: Dedicated `check_availability` node
- Story 3.4: Dedicated `suggest_pack` + `handle_pack_response` nodes
- Story 3.5: Dedicated `detect_indecision` + `offer_consultation` nodes

### Actual Implementation (Post-Pivot)

**Epic 2-3 Conversational: Consolidated into `conversational_agent`**
- Single node handles all conversational flows
- Tools provide functionality (check_availability, suggest_pack, offer_consultation)
- Claude orchestrates conversation naturally

**Rationale:** Original plan over-structured conversational flows, causing rigidity

---

### Deviation Summary

| Original Design | Actual Implementation | Reason for Change |
|-----------------|----------------------|-------------------|
| 13 conversational nodes | 1 conversational node | Reduce rigidity, enable natural flow |
| 158 state fields | 50 state fields | Simplify state management |
| Explicit awaiting states | No awaiting states | Claude handles conversation context |
| Topic change detection | No topic change needed | Claude naturally handles topic shifts |
| Node-per-feature | Tool-per-feature | Scales better, easier maintenance |

---

## Validation Criteria

### Success Metrics

‚úÖ **Code Complexity:**
- `conversation_flow.py` reduced to <250 lines
- ConversationState reduced to ‚â§60 fields
- LangGraph nodes reduced to ‚â§12 total

‚úÖ **Functional Validation:**
- Bot handles FAQ queries naturally (no awaiting states)
- Bot handles service inquiries conversationally
- Bot transitions to booking flow when intent clear
- Transactional flows (booking, payment) unchanged

‚úÖ **Test Validation:**
- All tests passing (unit + integration)
- Test code simplified (<50% LOC)
- Coverage maintained (‚â•85%)

‚úÖ **Documentation:**
- Architecture doc updated with hybrid pattern
- PRD clarified conversational flexibility
- 6 stories rewritten with accurate ACs
- BMAD 3.0 documenting change

---

## Conclusion

**Status:** ‚úÖ **APPROVED - READY FOR IMPLEMENTATION**

**Timeline:** 6 days (5 implementation + 1 documentation)

**Risk:** ‚ö†Ô∏è Medium (Claude prompt tuning may require iteration)

**Rollback Plan:** ‚úÖ Git branch revert (1 hour effort)

**Next Steps:** Handoff to Developer Agent for implementation (Phase 1-4)

---

**END OF BMAD 3.0**
