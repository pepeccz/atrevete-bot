# BMAD: AsyncRedisSaver Lifecycle Coupling

**Story:** 1.5 - Basic LangGraph State & Echo Bot
**Date:** 2025-10-28
**Severity:** Medium (Architectural limitation)
**Status:** ✅ Documented, ⚠️ Future refactoring consideration

---

## Behavior

### Architectural Pattern

After fixing the AsyncRedisSaver initialization (BMAD 1.5a), the implementation couples the entire message processing loop lifecycle with the checkpointer async context manager.

**Current Pattern** (`agent/main.py:46-157`):
```python
async def subscribe_to_incoming_messages():
    client = get_redis_client()
    settings = get_settings()

    # Checkpointer initialized via context manager
    async with AsyncRedisSaver.from_conn_string(settings.REDIS_URL) as checkpointer:
        logger.info("AsyncRedisSaver initialized successfully")

        graph = create_conversation_graph(checkpointer=checkpointer)

        # ALL message processing INSIDE context manager
        pubsub = client.pubsub()
        await pubsub.subscribe("incoming_messages")

        async for message in pubsub.listen():
            # Process messages...
            await graph.ainvoke(state, config=config)
```

### Implications

**Tight Coupling**: The entire subscription loop (potentially infinite) runs within the `async with` block, meaning:
1. Checkpointer cannot be closed/restarted without stopping message processing
2. Multiple worker processes each need their own checkpointer context
3. Horizontal scaling requires per-worker context manager initialization
4. Connection pool optimization is difficult

---

## Measure

### Current Implementation Analysis

**File:** `agent/main.py`
**Lines:** 46-157

**Coupling Points**:
- Checkpointer initialization: Line 52
- Graph creation: Line 56 (depends on checkpointer)
- Message loop: Lines 60-157 (entire loop inside context)

**Why This Pattern Was Chosen**:
- BMAD 1.5a discovered that AsyncRedisSaver REQUIRES async context manager
- Simplest working solution: Put everything inside `async with`
- Epic 1 only needs single worker, so no immediate scaling concerns

### Alternative Patterns (Not Implemented)

**Option 1: Application-Level Checkpointer** (more complex):
```python
# At application startup
checkpointer = await AsyncRedisSaver.from_conn_string(redis_url).__aenter__()

# Multiple workers share checkpointer
async def worker_1():
    graph = create_graph(checkpointer)
    await process_messages()

async def worker_2():
    graph = create_graph(checkpointer)
    await process_other_messages()

# At shutdown
await checkpointer.__aexit__(None, None, None)
```

**Trade-offs**:
- ✅ Better for horizontal scaling
- ❌ Manual lifecycle management (error-prone)
- ❌ Requires proper shutdown handling
- ❌ More complex error recovery

---

## Act

### Decision: Accept Current Pattern for Epic 1-6

**Rationale**:
1. **Epic 1-2**: Single agent worker sufficient
2. **Epic 3-5**: Scalability not yet required
3. **Epic 6**: If load requires scaling, refactor at that point
4. **Epic 7**: Production hardening may include multi-worker support

### Documentation of Limitation

**Added to Architecture Document** (Section: AsyncRedisSaver Pattern):
> **Lifecycle Coupling**: Current implementation couples message processing loop with checkpointer lifecycle. All processing MUST occur within the `async with` block.
>
> **Limitation**: This pattern makes horizontal scaling complex - each worker needs its own checkpointer context. Future refactoring may extract checkpointer initialization to application startup with proper connection pooling.

---

## Document

### Lessons Learned

1. **Context Manager Requirements**: LangGraph's AsyncRedisSaver mandates context manager usage, limiting architectural flexibility

2. **Single-Worker Simplicity**: For Epic 1-5 scope, single worker pattern is simpler and sufficient

3. **Scaling Consideration**: Document limitations early so future refactoring is anticipated

### Knowledge Base

**Current Pattern for Epic 2-6**:
```python
async with AsyncRedisSaver.from_conn_string(redis_url) as checkpointer:
    graph = create_conversation_graph(checkpointer=checkpointer)

    # All message processing here
    async for message in pubsub.listen():
        await graph.ainvoke(state, config=config)
```

**Future Refactoring** (Epic 6-7 if needed):
```python
class CheckpointerManager:
    """Manage AsyncRedisSaver lifecycle at application level."""

    async def __aenter__(self):
        self.checkpointer = await AsyncRedisSaver.from_conn_string(
            redis_url
        ).__aenter__()
        return self

    async def __aexit__(self, *args):
        await self.checkpointer.__aexit__(*args)

    def get_graph(self):
        """Return graph using shared checkpointer."""
        return create_conversation_graph(checkpointer=self.checkpointer)

# Application startup
async with CheckpointerManager() as manager:
    # Spawn multiple workers
    await asyncio.gather(
        worker_1(manager),
        worker_2(manager),
        worker_3(manager),
    )
```

### Testing Strategy

**Epic 1-6**: No changes needed, single worker tested via Story 1.5 manual tests

**Epic 7** (if multi-worker implemented):
- Integration test: Multiple workers processing messages concurrently
- Stress test: 100 concurrent conversations
- Checkpoint collision test: Verify thread-safety

### Related Issues

- **BMAD 1.5a**: AsyncRedisSaver context manager requirement
- **Epic 2 Story 2.5a**: Checkpointing & crash recovery (uses current pattern)
- **Epic 6**: Scalability considerations
- **Epic 7**: Production hardening (may trigger refactoring)

### Prevention

**Going Forward**:
- Document architectural limitations as they're discovered
- Revisit scaling assumptions during Epic 6 planning
- Add "Scalability Review" checkpoint before Epic 7

---

**Resolution Time**: N/A (architectural decision, not a bug)
**Related Files**: `agent/main.py:46-157`
**Impact**: Medium - Works perfectly for Epic 1-6, may need refactoring for horizontal scaling
**Epic 2+ Readiness**: ✅ Ready, pattern sufficient for current needs

**References**:
- BMAD 1.5a: AsyncRedisSaver initialization pattern
- LangGraph AsyncRedisSaver docs: Context manager requirement
- Python async context managers: https://docs.python.org/3/reference/datamodel.html#async-context-managers
